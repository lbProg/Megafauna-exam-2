---
title: "Capture-Mark-Recapture models of _Larus hyperboreus_"
author: 
    - Lucien Bastin
    - Lucie Fournil
date: 2025-09-17
format: html
knitr:
    opts_chunk:
        message: FALSE
        warning: FALSE
embed-resources: TRUE
lightbox: TRUE
toc: TRUE
toc-location: right-body
df-print: kable
---

# Setup

## Libraries

```{r}
#| eval: true

library(dplyr)
library(ggplot2)
library(here)
library(MCMCvis)
library(nimble)
```

## Data

```{r}
raw_data <- read.csv(here("Data/input.csv"))
```

```{r}
#| include: false
#| eval: true

load(here("Data/Models_croissant_seed1604_VF.RData"))
```

For reproducibility, we set the global seed and the seeds for each of the chains in our models.

```{r}
set.seed(1604)
chain_seeds <- c(1, 2, 3, 4)
```

Fetching the CMR data :

```{r}
y <- raw_data |>
    select(x97:x04) |>
    as.matrix()

first <- apply(y, 1, function(x) min(which(x != 0)))
n_obs <- sum(apply(y, 1, sum) != 0)

for (i in 1:n_obs) {
  if (first[i] > 1) y[i, 1:(first[i] - 1)] <- NA
}
```

Converting CMR data from 0-1 to 1-2 and storing sex in a vector :

```{r}
my.data <- list(y = y + 1)
SEX <- as.integer(raw_data$sex)
K <- length(unique(SEX))
N <- nrow(y)
T <- ncol(y)
TIME <- c(1, 2, 3, 4, 5, 6, 7, 8)
TIME <- as.numeric(scale(TIME))
```

```{r}
zinits <- function(y) {
  T <- length(y)
  first <- min(which(y != 0))
  last <- max(which(y == 1))
  z <- rep(NA, T)
  if (last == T) {
    z[first:T] <- 1
  } else {
    if (last == (T - 1)) {
      z[first:(T - 1)] <- 1
      z[T] <- sample(1:2, size = 1)
    } else {
      death <- sample((last + 1):T, size = 1)
      z[first:(death - 1)] <- 1
      z[death:T] <- 2
    }
  }
  return(z)
}
```

Global MCMC parameters :

```{r}
n_iter <- 10
n_burnin <-1
n_chains <- 4
n_thin <- 1
```

# 1. Preliminary analyses

Selecting a model where survival probabliity and detection probability depend on time and sex. We will compare WAIC values to select the best model.

From the most complex model to the most simple.

## Model 1

|      | $p$         | $\phi$      |
|------|-------------|-------------|
| Time | constant    | constant    |
| Sex  | constant    | constant    |

$p$ : Detectability could vary among years, depending on weather or the effort for example. Here, treating time as a categorical covariate rather than a continuous one allows a non-linear trend. It could also differ between sexes due to differences in their behavior.

$\phi$ : Survival could vary according to fluctuating environmental conditions. Moreover, sex differences in physiology, behavior or reproductive investment can make them more or less likely to survive.

Model code :

```{r}
hmm.p._phi. <- nimbleCode({
  delta[1] <- 1          
  delta[2] <- 0 
  
  phi~ dunif(0,1)
  omega[1,1] <- 1 - p
  omega[1,2] <- p
  omega[2,1] <- 1
  omega[2,2] <- 0
  
  p ~ dunif(0,1)
  gamma[1,1] <- phi
  gamma[1,2] <- 1 - phi
  gamma[2,1] <- 0
  gamma[2,2] <- 1
  
  
  for(i in 1:N){
    z[i, first[i]] ~ dcat(delta[1:2])
    for(j in (first[i]+1):T){
      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2])
      y[i,j] ~ dcat(omega[z[i,j], 1:2])
    }
  }
})
```

Setting the constants :

```{r}
my.constants <- list(
  N = N,
  T = T,
  first = first
)
```

Initial values of the four Markov Chains :

```{r}
makeinits <- function() {
  list(
    p   = runif(1,0,1),
    phi = runif(1,0,1),
    z   = t(apply(y, 1, zinits))
  )
}

initial.values <- replicate(4, makeinits(), simplify = FALSE)
```

Parameters to monitor :

```{r}
params <- c(
  "phi", "p"
)  
```

Running the MCMC :

```{r}
mcmc_p._phi. <- nimbleMCMC(
  code = hmm.p._phi.,
  constants = my.constants,
  data = my.data,
  inits = initial.values,
  monitors = params,
  niter = n_iter,
  nburnin = n_burnin,
  nchains = n_chains,
  summary = TRUE,
  setSeed = chain_seeds,
  WAIC = TRUE
)
```

```{r}
mcmc_p._phi.$WAIC
```

## Model 2

|      | $p$           | $\phi$      |
|------|---------------|-------------|
| Time | random effect | constant    |
| Sex  | constant      | constant    |

Detection is expected to fluctuate randomly among years due to variable field conditions.

Model code :

```{r}
hmm.p.timeRE_phi. <- nimbleCode({
  delta[1] <- 1          # Pr(alive t = 1) = 1
  delta[2] <- 0          # Pr(dead t = 1) = 0
  
  for (t in 1:(T-1)){
    logit(p[t]) <- mup + eps_p[t] # eps is the random effect (epsilon)
    eps_p[t] ~ dnorm(0, sd = sdeps_p)
    omega[1,1,t] <- 1 - p[t]    # Pr(alive t -> non-detected t)
    omega[1,2,t] <- p[t]        # Pr(alive t -> detected t)
    omega[2,1,t] <- 1           # Pr(dead t -> non-detected t)
    omega[2,2,t] <- 0           # Pr(dead t -> detected t)
  }

  phi ~ dunif(0, 1)          # prior detection
  gamma[1,1] <- phi      # Pr(alive t -> alive t+1)
  gamma[1,2] <- 1 - phi  # Pr(alive t -> dead t+1)
  gamma[2,1] <- 0           # Pr(dead t -> alive t+1)
  gamma[2,2] <- 1           # Pr(dead t -> dead t+1)
  
  
  # priors
  mup ~ dnorm(0, sd= 1.5) # prior intercept on the logit scale
  sdeps_p ~ dunif(0,10) # prior standard deviation for the random effect
  # likelihood
  for (i in 1:N){
    z[i,first[i]] ~ dcat(delta[1:2])
    for (j in (first[i]+1):T){
      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2])
      y[i,j] ~ dcat(omega[z[i,j], 1:2, j-1])
    }
  }
})
```

Setting the constants :

```{r}
my.constants <- list(N = N, T = T, first = first)
```

Initial values of the four Markov Chains :

```{r}
makeinits <- function() {
  list(
    mup = rnorm(1,0,1),
    sdeps_p = runif(1,0,3),
    phi = runif(1,0,1),
    z = t(apply(y, 1, zinits))
  )
}

initial.values <- replicate(4, makeinits(), simplify = FALSE)
```

Parameters to monitor :

```{r}
params <- c(
  "mup",
  "sdeps_p",
  "phi"
)
```

Running the MCMC :

```{r}
mcmc_p.timeRE_phi. <- nimbleMCMC(
  code = hmm.p.timeRE_phi.,
  constants = my.constants,
  data = my.data,
  inits = initial.values,
  monitors = params,
  niter = n_iter,
  nburnin = n_burnin,
  nchains = n_chains,
  summary = TRUE,
  setSeed = chain_seeds,
  WAIC = TRUE
)
```

```{r}
hmm.p.timeRE_phi.$WAIC
```

## Model 3

|      | $p$         | $\phi$      |
|------|-------------|-------------|
| Time | categorical | constant    |
| Sex  | constant    | constant    |

Detection could be stable accross years because of standardized protocols, same observer effort among years and site-fidelity of seabirds.

Model code :

```{r}
hmm.p.timeCAT_phi. <- nimbleCode({
  delta[1] <- 1          
  delta[2] <- 0 
  
  for(t in 1:(T-1)){
    p[t] ~ dunif(0,1)
    omega[1,1,t] <- 1 - p[t]
    omega[1,2,t] <- p[t]
    omega[2,1,t] <- 1
    omega[2,2,t] <- 0
  }
  
  phi ~ dunif(0, 1) 
  gamma[1,1] <- phi      
  gamma[1,2] <- 1 - phi  
  gamma[2,1] <- 0           
  gamma[2,2] <- 1           
  
  
  for(i in 1:N){
    z[i, first[i]] ~ dcat(delta[1:2])
    for(j in (first[i]+1):T){
      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2])
      y[i,j] ~ dcat(omega[z[i,j], 1:2,j-1])
    }
  }
})
```

Setting the constants :

```{r}
my.constants <- list(N = N, T = T, first = first)
```

Initial values of the four Markov Chains :

```{r}
makeinits <- function() {
  list(
    p = runif((T-1),0,1),
    phi = runif(1,0,1),
    z = t(apply(y, 1, zinits))
  )
}

initial.values <- replicate(4, makeinits(), simplify = FALSE)
```

Parameters to monitor :

```{r}
params <- c(
  "p",
  "phi"
)
```

Running the MCMC :

```{r}
mcmc_p.timeCAT_phi. <- nimbleMCMC(
  code = hmm.p.timeCAT_phi.,
  constants = my.constants,
  data = my.data,
  inits = initial.values,
  monitors = params,
  niter = n_iter,
  nburnin = n_burnin,
  nchains = 4,
  summary = TRUE,
  setSeed = chain_seeds,
  WAIC = TRUE
)
```

```{r}
mcmc_p.timeCAT_phi.$WAIC
```

## Model 4

|      | $p$      | $\phi$      |
|------|----------|-------------|
| Time | constant | constant |
| Sex  | categorical | constant |

In colonial seabirds, males and females attend nests at overlapping times. Because both sexes are equally present, observers are not more likely to detect one sex over the other.

Model code :

```{r}
hmm.p.sex_phi. <- nimbleCode({
  delta[1] <- 1          
  delta[2] <- 0 
  
  for(k in 1:K){
    p[k] ~ dunif(0,1)
  }
  
  for(i in 1:N){
    omega[1,1,i] <- 1 - p[SEX[i]]
    omega[1,2,i] <- p[SEX[i]]
    omega[2,1,i] <- 1
    omega[2,2,i] <- 0
  }

  phi ~ dunif(0, 1)          # prior detection
  gamma[1,1] <- phi      # Pr(alive t -> alive t+1)
  gamma[1,2] <- 1 - phi  # Pr(alive t -> dead t+1)
  gamma[2,1] <- 0           # Pr(dead t -> alive t+1)
  gamma[2,2] <- 1           # Pr(dead t -> dead t+1)
  
  for(i in 1:N){
    z[i, first[i]] ~ dcat(delta[1:2])
    for(j in (first[i]+1):T){
      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2])
      y[i,j] ~ dcat(omega[z[i,j], 1:2,i])
    }
  }
})
```

Setting the constants :

```{r}
my.constants <- list(N = N, T = T, first = first, SEX = SEX, K = K)
```

Initial values of the four Markov Chains :

```{r}
makeinits <- function() {
  list(
    p = runif(K,0,1),
    phi = runif(1,0,1),
    z = t(apply(y, 1, zinits))
  )
}

initial.values <- replicate(4, makeinits(), simplify = FALSE)
```

Parameters to monitor :

```{r}
params <- c(
  "p",
  "phi"
)
```

Running the MCMC :

```{r}
mcmc_p.sex_phi. <- nimbleMCMC(
  code = hmm.p.sex_phi.,
  constants = my.constants,
  data = my.data,
  inits = initial.values,
  monitors = params,
  niter = n_iter,
  nburnin = n_burnin,
  nchains = 4,
  summary = TRUE,
  setSeed = chain_seeds,
  WAIC = TRUE
)                                      
```

```{r}
mcmc_p.sex_phi.$WAIC
```

Since the best model for $p$ is **model 3** ($p$ depends only on sex as a categorical covariate), it was retained for selecting the best model for $\phi$.

## Model 5

|      | $p$         | $\phi$        |
|------|-------------|---------------|
| Time | constant    | random effect |
| Sex  | categorical | constant      |

Model code :

```{r}
hmm.p.sex_phi.timeRE <- nimbleCode({
  delta[1] <- 1          
  delta[2] <- 0 
  
  for(k in 1:K){
    p[k] ~ dunif(0,1)
  }
  
  for(i in 1:N){
    omega[1,1,i] <- 1 - p[SEX[i]]
    omega[1,2,i] <- p[SEX[i]]
    omega[2,1,i] <- 1
    omega[2,2,i] <- 0
  }
  
  for (t in 1:(T-1)){
    logit(phi[t]) <- muphi + eps_phi[t] # eps is the random effect (epsilon)
    eps_phi[t] ~ dnorm(0, sd = sdeps_phi)
    gamma[1,1,t] <- phi[t]      # Pr(alive t -> alive t+1)
    gamma[1,2,t] <- 1 - phi[t]  # Pr(alive t -> dead t+1)
    gamma[2,1,t] <- 0           # Pr(dead t -> alive t+1)
    gamma[2,2,t] <- 1           # Pr(dead t -> dead t+1)
  }
  
  muphi ~ dnorm(0, sd = 1.5)
  sdeps_phi ~ dunif(0, 10)
  
  for(i in 1:N){
    z[i, first[i]] ~ dcat(delta[1:2])
    for(j in (first[i]+1):T){
      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2,j-1])
      y[i,j] ~ dcat(omega[z[i,j], 1:2,i])
    }
  }
})
```

Setting the constants :

```{r}
my.constants <- list(N = N, T = T, first = first, SEX = SEX, K = K)                     
```

Initial values of the four Markov Chains :

```{r}
makeinits <- function() {
  list(
    p = runif(K,0,1),
    muphi = rnorm(1,0,1),
    sdeps_phi = runif(1,0,3),
    z = t(apply(y, 1, zinits))
  )
}

initial.values <- replicate(4, makeinits(), simplify = FALSE)
```

Parameters to monitor :

```{r}
params <- c("p", "muphi", "sdeps_phi")
```

Running the MCMC :

```{r}
mcmc_p.sex_phi.timeRE <- nimbleMCMC(
  code = hmm.p.sex_phi.timeRE,
  constants = my.constants,
  data = my.data,
  inits = initial.values,
  monitors = params,
  niter = n_iter,
  nburnin = n_burnin,
  nchains = 4,
  summary = TRUE,
  setSeed = chain_seeds,
  WAIC = TRUE
)
```

```{r}
mcmc_p.sex_phi.timeRE$WAIC
```

## Model 6

|      | $p$         | $\phi$      |
|------|-------------|-------------|
| Time | constant    | categorical |
| Sex  | categorical | constant    |

A continuous time effect allows survival to reflect gradual directional changes driven by long-term environmental or contaminant trends.

Model code :

```{r}
hmm.p.sex_phi.timeCAT <- nimbleCode({
  delta[1] <- 1          
  delta[2] <- 0 
  
  for(k in 1:K){
    p[k] ~ dunif(0,1)
  }
  
  for(i in 1:N){
    omega[1,1,i] <- 1 - p[SEX[i]]
    omega[1,2,i] <- p[SEX[i]]
    omega[2,1,i] <- 1
    omega[2,2,i] <- 0
  }
  
  for(t in 1:(T-1)){
    phi[t] ~ dunif(0,1)   # un p par année
    gamma[1,1,t] <- phi[t]
    gamma[1,2,t] <- 1 - phi[t]
    gamma[2,1,t] <- 0
    gamma[2,2,t] <- 1
  }

  
  for(i in 1:N){
    z[i, first[i]] ~ dcat(delta[1:2])
    for(j in (first[i]+1):T){
      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2,j-1])
      y[i,j] ~ dcat(omega[z[i,j], 1:2,i])
    }
  }
})

```

Setting the constants :

```{r}
my.constants <- list(N = N, T = T, first = first, SEX = SEX, K = K, TIME = TIME)
```

Initial values of the four Markov Chains :

```{r}
makeinits <- function() {
  list(
    p = runif(K,0,1),
    phi = runif(T-1,0,1),
    z = t(apply(y, 1, zinits))
  )
}

initial.values <- replicate(4, makeinits(), simplify = FALSE)
```

Parameters to monitor :

```{r}
params <- c("p", "phi")
```

Running the MCMC :

```{r}
mcmc_p.sex_phi.timeCAT <- nimbleMCMC(
  code = hmm.p.sex_phi.timeCAT,
  constants = my.constants,
  data = my.data,
  inits = initial.values,
  monitors = params,
  niter = n_iter,
  nburnin = n_burnin,
  nchains = 4,
  summary = TRUE,
  setSeed = chain_seeds,
  WAIC = TRUE
)                                          
```

```{r}
mcmc_p.sex_phi.timeCAT$WAIC
```

## Model 7

|      | $p$         | $\phi$      |
|------|-------------|-------------|
| Time | constant    | continuous  |
| Sex  | categorical | constant    |

Adult survival in long-lived species such as *Larus hyperboreus* can be buffered against short-term environmental fluctuations, so it can be considered as constant accoss years.

Model code :

```{r}
hmm.p.sex_phi.timeCONT <- nimbleCode({
  delta[1] <- 1          
  delta[2] <- 0 
  
  for(k in 1:K){
    p[k] ~ dunif(0,1)
  }
  
  for(i in 1:N){
    omega[1,1,i] <- 1 - p[SEX[i]]
    omega[1,2,i] <- p[SEX[i]]
    omega[2,1,i] <- 1
    omega[2,2,i] <- 0
  }
  
  for (t in 1:(T-1)){
    logit(phi[t]) <- alpha_phi0 + beta_time*(TIME[t]-1)
    gamma[1,1,t] <- phi[t]     # Pr(alive t -> alive t+1)
    gamma[1,2,t] <- 1 - phi[t]  # Pr(alive t -> dead t+1)
    gamma[2,1,t] <- 0           # Pr(dead t -> alive t+1)
    gamma[2,2,t] <- 1           # Pr(dead t -> dead t+1)
  }
  alpha_phi0 ~ dnorm(0, sd = 1.5) # prior intercept
  beta_time ~ dnorm(0, sd = 1.5) # prior slope
  
  for(i in 1:N){
    z[i, first[i]] ~ dcat(delta[1:2])
    for(j in (first[i]+1):T){
      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2,j-1])
      y[i,j] ~ dcat(omega[z[i,j], 1:2,i])
    }
  }
})
```

Setting the constants :

```{r}
my.constants <- list(N = N, T = T, first = first, SEX = SEX, K = K, TIME = TIME)
```

Initial values of the four Markov Chains :

```{r}
makeinits <- function() {
  list(
    p = runif(K,0,1),
    alpha_phi0 = rnorm(1,0,1),
    beta_time = rnorm(1,0,1),
    z = t(apply(y, 1, zinits))
  )
}

initial.values <- replicate(4, makeinits(), simplify = FALSE)
```

Parameters to monitor :

```{r}
params <- c("alpha_phi0","beta_time","p")
```

Running the MCMC :

```{r}
mcmc_p.sex_phi.timeCONT <- nimbleMCMC(
  code = hmm.p.sex_phi.timeCONT,
  constants = my.constants,
  data = my.data,
  inits = initial.values,
  monitors = params,
  niter = n_iter,
  nburnin = n_burnin,
  nchains = 4,
  summary = TRUE,
  setSeed = chain_seeds,
  WAIC = TRUE
)
```

```{r}
mcmc_p.sex_phi.timeCONT$WAIC
```

## Model 8

|      | $p$         | $\phi$        |
|------|-------------|---------------|
| Time | constant    | categorical   |
| Sex  | categorical | categorical   |

Model code :

```{r}
hmm.p.sex_phi.timeCAT.sex <- nimbleCode({
  delta[1] <- 1          
  delta[2] <- 0

  alpha_phi0 ~ dnorm(0, sd = 1.5)
  
  beta_phi_sex[1] <- 0
  for (k in 2:K){
    beta_phi_sex[k] ~ dnorm(0, sd = 1.5)
  }

  beta_phi_time[1] <- 0
  for (t in 2:(T - 1)) {
    beta_phi_time[t] ~ dnorm(0, sd = 1.5)
  }
  
  for(i in 1:N){
    for(t in 1:(T-1)){
      logit(phi[i,t]) <- alpha_phi0 + beta_phi_time[t] + beta_phi_sex[SEX[i]]
      gamma[1,1,i,t] <- phi[i,t]
      gamma[1,2,i,t] <- 1 - phi[i,t]
      gamma[2,1,i,t] <- 0
      gamma[2,2,i,t] <- 1
    }
  }
  
  for(k in 1:K){
    p[k] ~ dunif(0,1)
  }
  
  for(i in 1:N){
    omega[1,1,i] <- 1 - p[SEX[i]]
    omega[1,2,i] <- p[SEX[i]]
    omega[2,1,i] <- 1
    omega[2,2,i] <- 0
  }
  
  for(i in 1:N){
    z[i, first[i]] ~ dcat(delta[1:2])
    for(j in (first[i]+1):T){
      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2,i,j-1])
      y[i,j] ~ dcat(omega[z[i,j], 1:2,i])
    }
  }
})
```

Setting the constants :

```{r}
my.constants <- list(N = N, T = T, first = first, SEX = SEX, K = K)
```

Initial values of the four Markov Chains :

```{r}
makeinits <- function() {
  list(
    p   = runif(K,0,1),
    alpha_phi0 = rnorm(1, 0, sd = 1.5),
    beta_phi_sex = c(0, rnorm(K-1,0,1.5)),
    beta_phi_time = c(0, rnorm(T - 2, 0, sd = 1.5)),
    z   = t(apply(y, 1, zinits))
  )
}

initial.values <- replicate(4, makeinits(), simplify = FALSE)
```

Parameters to monitor :

```{r}
params <- c("p", "beta_phi_sex", "alpha_phi0", "beta_phi_time")
```

Running the MCMC :

```{r}
mcmc_p.sex_phi.timeCAT.sex <- nimbleMCMC(
  code = hmm.p.sex_phi.timeCAT.sex,
  constants = my.constants,
  data = my.data,
  inits = initial.values,
  monitors = params,
  niter = n_iter,
  nburnin = n_burnin,
  nchains = 4,
  summary = TRUE,
  setSeed = chain_seeds,
  WAIC = TRUE
)
```

```{r}
mcmc_p.sex_phi.timeCAT.sex$WAIC
```

## Summary WAIC

|         |            |             |               |                |           |
|:-------:|:----------:|:-----------:|:-------------:|:--------------:|:---------:|
| Model   | $p ~ sex$  | $p \~ time$ | $\phi \~ sex$ | $\phi \~ time$ |  $WAIC$   |
|    1    |    cat     |     cat     |      cat      |      cat       |    541    |
|    2    |    cat     |     RE      |      cat      |      cat       |    552    |
|    3    |    cat     |  constant   |      cat      |      cat       |    557    |
|    4    |  constant  |  constant   |      cat      |      cat       |    537    |
|    5    |    cat     |  constant   |      cat      |       RE       |    533    |
|    6    |    cat     |  constant   |      cat      |   continuous   |  **529\***|
|    7    |    cat     |  constant   |      cat      |    constant    |    531    |
|    8    |    cat     |  constant   |   constant    |       RE       |    535    |

cat = categorical ; RE = random effect

**\***Best model

We selected **model 6** for subsequent analyses.

# 2. Effect of oxychlordane (OXY)

## Encode oxy

Encoding $log(OXY)$ as a continuous variable (OXY) :

```{r}
log_oxy <- log(raw_data$oxy)
```

Encoding $log(OXY)$ as a categorical variable (OXYD) :

```{r}
quantiles <- quantile(log_oxy, probs = seq(0, 1, by = 0.1))

oxyd <- log_oxy |>
  cut(
    breaks = quantiles,
    labels = seq(1, 10, 1),
    include.lowest = TRUE
  ) |>
  as.numeric()
```

Pool all deciles except the last n :

```{r}
pool_n <- function(data, sex, n_female, n_male) {
  levels_d <- sort(unique(data))

  unique_d_female <- tail(levels_d, n_female)
  unique_d_male <- tail(levels_d, n_male)

  # 1 is male and 2 is female
  data[sex == 2 & !(data %in% unique_d_female)] <- 1
  data[sex == 1 & !(data %in% unique_d_male)] <- 1

  match(data, levels(factor(data)))
}
```

```{r}
data.frame(x = oxyd, SEX = raw_data$sex, y = pool_n(oxyd, raw_data$sex, 2, 3))
```

## Model selection strategy

We will test the folowing models to compare them :

| Model | $log(OXY)$  | male threshold | female threshold |
|-------|-------------|----------------|------------------|
| 1     | continuous  | na             | na               |
| 2     | categorical | 0              | 0                |
| 3     | categorical | 2              | 2                |
| 5     | categorical | 3              | 3                |
| 6     | categorical | 2              | 3                |

## Running the models : phi depends on OXY

### $log(OXY)$ as a continuous variable

Scale $log(OXY)$

```{r}
log_oxy_sc <- as.vector(scale(log_oxy))
SEX <- as.integer(raw_data$sex)
G <- length(unique(oxyd))
```

```{r}
hmm.p.sex_phi.timeCAT.oxyCONT <- nimbleCode({
  delta[1] <- 1          
  delta[2] <- 0 
  
  for(k in 1:K){
    p[k] ~ dunif(0,1)
  }
  
  for(i in 1:N){
    omega[1,1,i] <- 1 - p[SEX[i]]
    omega[1,2,i] <- p[SEX[i]]
    omega[2,1,i] <- 1
    omega[2,2,i] <- 0
  }
  
  beta_time[1] <- 0
  for(t in 2:(T-1)){
    beta_time[t] ~ dnorm(0, sd = 1.5)
  }
  
  for (t in 1:(T-1)){
    logit(phi[t]) <- alpha_phi0 + beta_oxy * OXY[t] + beta_time[t]
    gamma[1,1,t] <- phi[t]      # Pr(alive t -> alive t+1)
    gamma[1,2,t] <- 1 - phi[t]  # Pr(alive t -> dead t+1)
    gamma[2,1,t] <- 0           # Pr(dead t -> alive t+1)
    gamma[2,2,t] <- 1           # Pr(dead t -> dead t+1)
  }
  
  alpha_phi0 ~ dnorm(0, sd = 1.5)
  beta_oxy   ~ dnorm(0, sd = 1.5) 
  
  for(i in 1:N){
    z[i, first[i]] ~ dcat(delta[1:2])
    for(j in (first[i]+1):T){
      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2,j-1])
      y[i,j] ~ dcat(omega[z[i,j], 1:2,i])
    }
  }
})
```

```{r}
my.constants <- list(
  N = N,
  T = T,
  SEX = SEX,
  K = K,
  first = first,
  OXY = log_oxy_sc
)
```

```{r}
makeinits <- function() {
  list(
    p = runif(K,0,1),
    alpha_phi0 = rnorm(1,0,1),
    beta_oxy = rnorm(1,0,1),
    beta_time = c(0, rnorm(T-2,0,1.5)),
    z = t(apply(y, 1, zinits))
  )
}

initial.values <- replicate(4, makeinits(), simplify = FALSE)
```

```{r}
params = c("p", "alpha_phi0", "beta_oxy", "beta_time")
```

```{r}
mcmc_p.sex_phi.timeCAT.oxyCONT <- nimbleMCMC(
  code = hmm.p.sex_phi.timeCAT.oxyCONT,
  constants = my.constants,
  data = my.data,
  inits = initial.values,
  monitors = params,
  niter = n_iter,
  nburnin = n_burnin,
  nchains = n_chains,
  summary = TRUE,
  setSeed = chain_seeds,
  WAIC = TRUE
)
```

```{r}
mcmc_p.sex_phi.timeCAT.oxyCONT$WAIC
```

### $log(OXY)$ as a categorical variable

```{r}
hmm.p.sex_phi.timeCAT.oxyCAT <- nimbleCode({
  delta[1] <- 1          
  delta[2] <- 0 
  
  for(k in 1:K){
    p[k] ~ dunif(0,1)
  }
  
  for(i in 1:N){
    omega[1,1,i] <- 1 - p[SEX[i]]
    omega[1,2,i] <- p[SEX[i]]
    omega[2,1,i] <- 1
    omega[2,2,i] <- 0
  }
  
  beta_time[1] <- 0
  for(t in 2:(T-1)){
    beta_time[t] ~ dnorm(0, sd = 1.5)
  }
  
  beta_oxy[1] <- 0
  for(g in 2:G){
    beta_oxy[g] ~ dnorm(0, sd = 1.5)
  }
  
  for(i in 1:N){
    for (t in 1:(T-1)){
      logit(phi[i,t]) <- alpha_phi0 + beta_oxy[oxyd[i]] + beta_time[t]
      gamma[1,1,i,t] <- phi[i,t]      # Pr(alive t -> alive t+1)
      gamma[1,2,i,t] <- 1 - phi[i,t]  # Pr(alive t -> dead t+1)
      gamma[2,1,i,t] <- 0           # Pr(dead t -> alive t+1)
      gamma[2,2,i,t] <- 1           # Pr(dead t -> dead t+1)
    }
  }
  
  alpha_phi0 ~ dnorm(0, sd = 1.5)
  
  for(i in 1:N){
    z[i, first[i]] ~ dcat(delta[1:2])
    for(j in (first[i]+1):T){
      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2,i,j-1])
      y[i,j] ~ dcat(omega[z[i,j], 1:2,i])
    }
  }
})
```

```{r}
constants <- list(
  N = N,
  T = T,
  SEX = SEX,
  K = K,
  G = G,
  first = first,
  oxyd = oxyd
)
```

```{r}
makeinits <- function() {
  list(
    p = runif(K,0,1),
    alpha_phi0 = rnorm(1,0,1),
    beta_oxy = c(0, rnorm(G-1,0,1)),
    beta_time = c(0, rnorm(T-2,0,1.5)),
    z = t(apply(y, 1, zinits))
  )
}

initial.values <- replicate(4, makeinits(), simplify = FALSE)
```

```{r}
monitor = c("p", "alpha_phi0", "beta_oxy", "beta_time")
```

```{r}
mcmc_p.sex_phi.timeCAT.oxyCAT <- nimbleMCMC(
  code = hmm.p.sex_phi.timeCAT.oxyCAT,
  constants = constants,
  data = my.data,
  inits = initial.values,
  monitors = params,
  niter = n_iter,
  nburnin = n_burnin,
  nchains = n_chains,
  setSeed = chain_seeds,
  summary = TRUE,
  WAIC = TRUE
)
```

```{r}
mcmc_p.sex_phi.timeCAT.oxyCAT$WAIC
```

### $log(OXY)$ as a pooled categorical variable (except last two deciles)

```{r}
oxyd_2D <- pool_n(oxyd, raw_data$sex, 2, 2)
G <- length(unique(oxyd_2D))
```

```{r}
constants <- list(
  N = N,
  T = T,
  SEX = SEX,
  K = K,
  G = G,
  first = first,
  oxyd = oxyd_2D
)
```

```{r}
initial.values <- replicate(4, makeinits(), simplify = FALSE)
```

```{r}
mcmc_p.sex_phi.timeCAT.oxyCAT2D <- nimbleMCMC(
  code = hmm.p.sex_phi.timeCAT.oxyCAT,
  constants = constants,
  data = my.data,
  inits = initial.values,
  monitors = params,
  niter = n_iter,
  nburnin = n_burnin,
  nchains = n_chains,
  setSeed = chain_seeds,
  summary = TRUE,
  WAIC = TRUE
)
```

```{r}
mcmc_p.sex_phi.timeCAT.oxyCAT2D$WAIC
```

### $log(OXY)$ as a pooled categorical variable (except last three deciles)

```{r}
oxyd_3D <- pool_n(oxyd, raw_data$sex, 3, 3)
G <- length(unique(oxyd_3D))
```

```{r}
constants <- list(
  N = N,
  T = T,
  SEX = SEX,
  K = K,
  G = G,
  first = first,
  oxyd = oxyd_3D
)
```

```{r}
initial.values <- replicate(4, makeinits(), simplify = FALSE)
```

```{r}
mcmc_p.sex_phi.timeCAT.oxyCAT3D <- nimbleMCMC(
  code = hmm.p.sex_phi.timeCAT.oxyCAT,
  constants = constants,
  data = my.data,
  inits = initial.values,
  monitors = params,
  niter = n_iter,
  nburnin = n_burnin,
  nchains = n_chains,
  setSeed = chain_seeds,
  summary = TRUE,
  WAIC = TRUE
)
```

```{r}
mcmc_p.sex_phi.timeCAT.oxyCAT3D$WAIC
```

### $log(OXY)$ as a pooled categorical variable (except last two or three deciles depending on sex)

```{r}
oxyd_mf <- pool_n(oxyd, raw_data$sex, 2, 3)
G <- length(unique(oxyd_mf))
```

```{r}
hmm.p.sex_phi.timeCAT.oxyCAT_2DF3DM <- nimbleCode({
  delta[1] <- 1          
  delta[2] <- 0 
  
  for(k in 1:K){
    p[k] ~ dunif(0,1)
  }
  
  for(i in 1:N){
    omega[1,1,i] <- 1 - p[SEX[i]]
    omega[1,2,i] <- p[SEX[i]]
    omega[2,1,i] <- 1
    omega[2,2,i] <- 0
  }
  
  beta_time[1] <- 0
  for(t in 2:(T-1)){
    beta_time[t] ~ dnorm(0, sd = 1.5)
  }
  
  beta_oxy[1,1] <- 0
  for(g in 2:G){
    beta_oxy[1,g] ~ dnorm(0, sd = 1.5)
  }
  
  for(g in 1:G){
    beta_oxy[2,g] ~ dnorm(0, sd = 1.5)
  }
  
  for(i in 1:N){
    for (t in 1:(T-1)){
      logit(phi[i,t]) <- alpha_phi0 + beta_oxy[SEX[i], oxyd[i]] + beta_time[t]
      gamma[1,1,i,t] <- phi[i,t]      # Pr(alive t -> alive t+1)
      gamma[1,2,i,t] <- 1 - phi[i,t]  # Pr(alive t -> dead t+1)
      gamma[2,1,i,t] <- 0           # Pr(dead t -> alive t+1)
      gamma[2,2,i,t] <- 1           # Pr(dead t -> dead t+1)
    }
  }
  
  alpha_phi0 ~ dnorm(0, sd = 1.5)
  
  for(i in 1:N){
    z[i, first[i]] ~ dcat(delta[1:2])
    for(j in (first[i]+1):T){
      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2,i,j-1])
      y[i,j] ~ dcat(omega[z[i,j], 1:2,i])
    }
  }
})
```

```{r}
constants <- list(
  N = N,
  T = T,
  SEX = SEX,
  K = K,
  G = G,
  first = first,
  oxyd = oxyd_mf
)
```

```{r}
makeinits <- function() {
  B <- matrix(rnorm(8, 0, 1), nrow = K, ncol = G)
  B[1,1] <- 0
  
  list(
    p = runif(K, 0, 1),
    alpha_phi0 = rnorm(1, 0, 1),
    beta_time = c(0, rnorm(T-2, 0, 1.5)),
    beta_oxy = B,
    z = t(apply(y, 1, zinits))
  )
}

initial.values <- replicate(4, makeinits(), simplify = FALSE)
```

```{r}
mcmc_p.sex_phi.timeCAT.oxyCAT_2DF3DM  <- nimbleMCMC(
  code = hmm.p.sex_phi.timeCAT.oxyCAT_2DF3DM,
  constants = constants,
  data = my.data,
  inits = initial.values,
  monitors = params,
  niter = n_iter,
  nburnin = n_burnin,
  nchains = n_chains,
  setSeed = chain_seeds,
  summary = TRUE,
  WAIC = TRUE
)
```

```{r}
mcmc_p.sex_phi.timeCAT.oxyCAT_2DF3DM$WAIC
```