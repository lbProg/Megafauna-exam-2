---
title: "Capture-Mark-Recapture models of _Larus hyperboreus_"
author: 
    - Lucien Bastin
    - Lucie Fournil
date: 2025-09-17
format: html
knitr:
    opts_chunk:
        message: FALSE
        warning: FALSE
embed-resources: TRUE
lightbox: TRUE
toc: TRUE
toc-location: right-body
df-print: kable
---

# Setup

## Libraries

```{r}
library(dplyr)
library(ggplot2)
library(here)
library(MCMCvis)
library(nimble)
```

## Data

```{r}
raw_data <- read.csv(here("Data/input.csv"))
```

For reproducibility, we set the global seed and the seeds for each of the chains in our models.

```{r}
set.seed(1604)
chain_seeds <- c(1, 2, 3, 4)
```

Fetching the CMR data :

```{r}
y <- raw_data |>
    select(x97:x04) |>
    as.matrix()

first <- apply(y, 1, function(x) min(which(x != 0)))
n_obs <- sum(apply(y, 1, sum) != 0)

for (i in 1:n_obs) {
  if (first[i] > 1) y[i, 1:(first[i] - 1)] <- NA
}
```

Converting CMR data from 0-1 to 1-2 and storing sex in a vector :

```{r}
my.data <- list(y = y + 1)
SEX <- as.integer(raw_data$sex)
K <- length(unique(SEX))
N <- nrow(y)
T <- ncol(y)
TIME <- c(1, 2, 3, 4, 5, 6, 7, 8)
TIME <- as.numeric(scale(TIME))
```

```{r}
zinits <- function(y) {
  T <- length(y)
  first <- min(which(y != 0))
  last <- max(which(y == 1))
  z <- rep(NA, T)
  if (last == T) {
    z[first:T] <- 1
  } else {
    if (last == (T - 1)) {
      z[first:(T - 1)] <- 1
      z[T] <- sample(1:2, size = 1)
    } else {
      death <- sample((last + 1):T, size = 1)
      z[first:(death - 1)] <- 1
      z[death:T] <- 2
    }
  }
  return(z)
}
```

Global MCMC parameters :

```{r}
n_iter <- 20000
n_burnin <-5000
n_chains <- 4
n_thin <- 1
```

# 1. Preliminary analyses

Selecting a model where survival probabliity and detection probability depend on time and sex. We will compare WAIC values to select the best model.

From the modt complex model to the most simple.

## Model 1

|      | $p$         | $\phi$      |
|------|-------------|-------------|
| Time | categorical | categorical |
| Sex  | categorical | categorical |

Model code :

```{r}
hmm.p.time.sex_phi.time.sex <- nimbleCode({
  delta[1] <- 1
  delta[2] <- 0

  alpha_p0 ~ dnorm(0, sd = 1.5)
  alpha_phi0 ~ dnorm(0, sd = 1.5)

  beta_p_time[1] <- 0
  beta_phi_time[1] <- 0
  for (t in 2:(T - 1)) {
    beta_p_time[t] ~ dnorm(0, sd = 1.5)
    beta_phi_time[t] ~ dnorm(0, sd = 1.5)
  }

  beta_p_sex[1] <- 0
  beta_phi_sex[1] <- 0
  for (k in 2:K) {
    beta_p_sex[k] ~ dnorm(0, sd = 1.5)
    beta_phi_sex[k] ~ dnorm(0, sd = 1.5)
  }

  # Likelihoods

  for (t in 1:(T - 1)) {
    for (k in 1:K) {
      logit(p[t, k]) <- alpha_p0 + beta_p_time[t] + beta_p_sex[k]
      logit(phi[t, k]) <- alpha_phi0 + beta_phi_time[t] + beta_phi_sex[k]
    }
  }

  for (i in 1:N) {
    for (t in 1:(T - 1)) {
      # Detection
      omega[1, 1, t, i] <- 1 - p[t, SEX[i]]
      omega[1, 2, t, i] <- p[t, SEX[i]]
      omega[2, 1, t, i] <- 1
      omega[2, 2, t, i] <- 0

      # Transition
      gamma[1, 1, t, i] <- phi[t, SEX[i]]
      gamma[1, 2, t, i] <- 1 - phi[t, SEX[i]]
      gamma[2, 1, t, i] <- 0
      gamma[2, 2, t, i] <- 1
    }
  }

  for (i in 1:N) {
    z[i, first[i]] ~ dcat(delta[1:2])
    for (j in (first[i] + 1):T) {
      z[i, j] ~ dcat(gamma[z[i, j - 1], 1:2, j - 1, i])
      y[i, j] ~ dcat(omega[z[i, j], 1:2, j - 1, i])
    }
  }
})
```

Setting the constants :

```{r}
my.constants <- list(N = N, T = T, first = first, SEX = SEX, K = K)
```

Initial values of the four Markov Chains :

```{r}
makeinits <- function() {
  list(
    alpha_p0 = rnorm(1, 0, sd = 1.5),
    alpha_phi0 = rnorm(1, 0, sd = 1.5),

    beta_p_time = c(0, rnorm(T - 2, 0, sd = 1.5)),
    beta_phi_time = c(0, rnorm(T - 2, 0, sd = 1.5)),

    beta_p_sex = c(0, rnorm(K - 1, 0, sd = 1.5)),
    beta_phi_sex = c(0, rnorm(K - 1, 0, sd = 1.5)),

    z = t(apply(y, 1, zinits))
  )
}

initial.values <- replicate(4, makeinits(), simplify = FALSE)
```

Parameters to monitor :

```{r}
params <- c(
  "alpha_p0",
  "alpha_phi0",
  "beta_p_time",
  "beta_phi_time",
  "beta_p_sex",
  "beta_phi_sex",
  "p",
  "phi"
)  
```

Running the MCMC :

```{r}
mcmc_p.time.sex_phi.time.sex <- nimbleMCMC(
  code = hmm.p.time.sex_phi.time.sex,
  constants = my.constants,
  data = my.data,
  inits = initial.values,
  monitors = params,
  niter = 20000,
  nburnin = 5000,
  nchains = 4,
  summary = TRUE,
  setSeed = chain_seeds,
  WAIC = TRUE
)
```

```{r}
mcmc_p.time.sex_phi.time.sex$WAIC
```

## Model 2

|      | $p$           | $\phi$      |
|------|---------------|-------------|
| Time | random effect | categorical |
| Sex  | categorical   | categorical |

Model code :

```{r}
hmm.p.timeRE.sex_phi.timeCAT.sex <- nimbleCode({
  delta[1] <- 1
  delta[2] <- 0

  for (t in 1:(T - 1)) {
    eps_p[t] ~ dnorm(0, sd = sdeps_p)
  }

  beta_p_sex[1] <- 0
  for (k in 2:K) {
    beta_p_sex[k] ~ dnorm(0, sd = 1.5)
  }

  alpha_phi0 ~ dnorm(0, sd = 1.5)
  beta_phi_time[1] <- 0
  for (t in 2:(T - 1)) {
    beta_phi_time[t] ~ dnorm(0, sd = 1.5)
  }
  beta_phi_sex[1] <- 0
  for (k in 2:K) {
    beta_phi_sex[k] ~ dnorm(0, sd = 1.5)
  }

  for (t in 1:(T - 1)) {
    for (k in 1:K) {
      logit(phi[t, k]) <- alpha_phi0 + beta_phi_time[t] + beta_phi_sex[k]
    }
  }

  for (i in 1:N) {
    for (t in 1:(T - 1)) {
      logit(p[i, t]) <- mup + beta_p_sex[SEX[i]] + eps_p[t]
      omega[1, 1, i, t] <- 1 - p[i, t]
      omega[1, 2, i, t] <- p[i, t]
      omega[2, 1, i, t] <- 1
      omega[2, 2, i, t] <- 0

      gamma[1, 1, t, i] <- phi[t, SEX[i]]
      gamma[1, 2, t, i] <- 1 - phi[t, SEX[i]]
      gamma[2, 1, t, i] <- 0
      gamma[2, 2, t, i] <- 1
    }
  }

  # priors
  mup ~ dnorm(0, sd = 1.5) # prior intercept on the logit scale
  sdeps_p ~ dunif(0, 10) # prior standard deviation for the random effect
  # likelihood
  for (i in 1:N) {
    z[i, first[i]] ~ dcat(delta[1:2])
    for (j in (first[i] + 1):T) {
      z[i, j] ~ dcat(gamma[z[i, j - 1], 1:2, j - 1, i])
      y[i, j] ~ dcat(omega[z[i, j], 1:2, i, j - 1])
    }
  }
})
```

Setting the constants :

```{r}
my.constants <- list(N = N, T = T, first = first, SEX = SEX, K = K)
```

Initial values of the four Markov Chains :

```{r}
makeinits <- function() {
  list(
    mup = rnorm(1, 0, 1),
    sdeps_p = runif(1, 0, 3),
    beta_p_sex = runif(c(0, rnorm(K - 1, 0, 1.5))),
    alpha_phi0 = rnorm(1, 0, sd = 1.5),
    beta_phi_time = c(0, rnorm(T - 2, 0, sd = 1.5)),
    beta_phi_sex = c(0, rnorm(K - 1, 0, sd = 1.5)),
    z = t(apply(y, 1, zinits))
  )
}

initial.values <- replicate(4, makeinits(), simplify = FALSE)
```

Parameters to monitor :

```{r}
params <- c(
  "mup",
  "sdeps_p",
  "beta_p_sex",
  "alpha_phi0",
  "beta_phi_time",
  "beta_phi_sex")
```

Running the MCMC :

```{r}
mcmc_p.timeRE.sex_phi.timeCAT.sex <- nimbleMCMC(
  code = hmm.p.timeRE.sex_phi.timeCAT.sex,
  constants = my.constants,
  data = my.data,
  inits = initial.values,
  monitors = params,
  niter = 20000,
  nburnin = 5000,
  nchains = 4,
  summary = TRUE,
  setSeed = chain_seeds,
  WAIC = TRUE
)
```

```{r}
mcmc_p.timeRE.sex_phi.timeCAT.sex$WAIC
```

## Model 3

|      | $p$         | $\phi$      |
|------|-------------|-------------|
| Time | constant    | categorical |
| Sex  | categorical | categorical |

Model code :

```{r}
hmm.p.sex_phi.timeCAT.sex <- nimbleCode({
  delta[1] <- 1
  delta[2] <- 0

  for (k in 1:K) {
    p[k] ~ dunif(0, 1)
  }

  for (i in 1:N) {
    omega[1, 1, i] <- 1 - p[SEX[i]]
    omega[1, 2, i] <- p[SEX[i]]
    omega[2, 1, i] <- 1
    omega[2, 2, i] <- 0
  }

  alpha_phi0 ~ dnorm(0, sd = 1.5)
  beta_phi_time[1] <- 0
  for (t in 2:(T - 1)) {
    beta_phi_time[t] ~ dnorm(0, sd = 1.5)
  }
  beta_phi_sex[1] <- 0
  for (k in 2:K) {
    beta_phi_sex[k] ~ dnorm(0, sd = 1.5)
  }

  for (t in 1:(T - 1)) {
    for (k in 1:K) {
      logit(phi[t, k]) <- alpha_phi0 + beta_phi_time[t] + beta_phi_sex[k]
    }
  }

  for (i in 1:N) {
    for (t in 1:(T - 1)) {
      gamma[1, 1, t, i] <- phi[t, SEX[i]]
      gamma[1, 2, t, i] <- 1 - phi[t, SEX[i]]
      gamma[2, 1, t, i] <- 0
      gamma[2, 2, t, i] <- 1
    }
  }

  for (i in 1:N) {
    z[i, first[i]] ~ dcat(delta[1:2])
    for (j in (first[i] + 1):T) {
      z[i, j] ~ dcat(gamma[z[i, j - 1], 1:2, j - 1, i])
      y[i, j] ~ dcat(omega[z[i, j], 1:2, i])
    }
  }
})
```

Setting the constants :

```{r}
my.constants <- list(N = N, T = T, first = first, SEX = SEX, K = K)
```

Initial values of the four Markov Chains :

```{r}
makeinits <- function() {
  list(
    p = runif(K, 0, 1),
    alpha_phi0 = rnorm(1, 0, sd = 1.5),
    beta_phi_time = c(0, rnorm(T - 2, 0, sd = 1.5)),
    beta_phi_sex = c(0, rnorm(K - 1, 0, sd = 1.5)),
    z = t(apply(y, 1, zinits))
  )
}

initial.values <- replicate(4, makeinits(), simplify = FALSE)
```

Parameters to monitor :

```{r}
params <- c(
  "p",
  "alpha_phi0",
  "beta_phi_time",
  "beta_phi_sex"
)
```

Running the MCMC :

```{r}
mcmc_p.sex_phi.timeCAT.sex <- nimbleMCMC(
  code = hmm.p.sex_phi.timeCAT.sex,
  constants = my.constants,
  data = my.data,
  inits = initial.values,
  monitors = params,
  niter = 20000,
  nburnin = 5000,
  nchains = 4,
  summary = TRUE,
  setSeed = chain_seeds,
  WAIC = TRUE
)
```

```{r}
mcmc_p.sex_phi.timeCAT.sex$WAIC
```

## Model 4

|      | $p$      | $\phi$      |
|------|----------|-------------|
| Time | constant | categorical |
| Sex  | constant | categorical |

Model code :

```{r}
hmm.p._phi.timeCAT.sex <- nimbleCode({
  delta[1] <- 1
  delta[2] <- 0

  p ~ dunif(0, 1)
  omega[1, 1] <- 1 - p
  omega[1, 2] <- p
  omega[2, 1] <- 1
  omega[2, 2] <- 0

  alpha_phi0 ~ dnorm(0, sd = 1.5)
  beta_phi_time[1] <- 0
  for (t in 2:(T - 1)) {
    beta_phi_time[t] ~ dnorm(0, sd = 1.5)
  }
  beta_phi_sex[1] <- 0
  for (k in 2:K) {
    beta_phi_sex[k] ~ dnorm(0, sd = 1.5)
  }

  for (t in 1:(T - 1)) {
    for (k in 1:K) {
      logit(phi[t, k]) <- alpha_phi0 + beta_phi_time[t] + beta_phi_sex[k]
    }
  }

  for (i in 1:N) {
    for (t in 1:(T - 1)) {
      gamma[1, 1, t, i] <- phi[t, SEX[i]]
      gamma[1, 2, t, i] <- 1 - phi[t, SEX[i]]
      gamma[2, 1, t, i] <- 0
      gamma[2, 2, t, i] <- 1
    }
  }

  for (i in 1:N) {
    z[i, first[i]] ~ dcat(delta[1:2])
    for (j in (first[i] + 1):T) {
      z[i, j] ~ dcat(gamma[z[i, j - 1], 1:2, j - 1, i])
      y[i, j] ~ dcat(omega[z[i, j], 1:2])
    }
  }
})
```

Setting the constants :

```{r}
my.constants <- list(N = N, T = T, first = first, SEX = SEX, K = K)
```

Initial values of the four Markov Chains :

```{r}
makeinits <- function() {
  list(
    p = runif(1, 0, 1),
    alpha_phi0 = rnorm(1, 0, sd = 1.5),
    beta_phi_time = c(0, rnorm(T - 2, 0, sd = 1.5)),
    beta_phi_sex = c(0, rnorm(K - 1, 0, sd = 1.5)),
    z = t(apply(y, 1, zinits))
  )
}

initial.values <- replicate(4, makeinits(), simplify = FALSE)
```

Parameters to monitor :

```{r}
params <- c(
  "p",
  "alpha_phi0",
  "beta_phi_time",
  "beta_phi_sex"
)
```

Running the MCMC :

```{r}
mcmc_p._phi.timeCAT.sex <- nimbleMCMC(
  code = hmm.p._phi.timeCAT.sex,
  constants = my.constants,
  data = my.data,
  inits = initial.values,
  monitors = params,
  niter = 20000,
  nburnin = 5000,
  nchains = 4,
  summary = TRUE,
  setSeed = chain_seeds,
  WAIC = TRUE
)                                      
```

```{r}
mcmc_p._phi.timeCAT.sex$WAIC
```

## Model 5

|      | $p$         | $\phi$        |
|------|-------------|---------------|
| Time | constant    | random effect |
| Sex  | categorical | categorical   |

Model code :

```{r}
hmm.p.sex_phi.timeRE.sex <- nimbleCode({
  delta[1] <- 1
  delta[2] <- 0

  beta_sex_phi[1] <- 0
  for (k in 2:K) {
    beta_sex_phi[k] ~ dnorm(0, sd = 1.5)
  }
  for (t in 1:(T - 1)) {
    eps_phi[t] ~ dnorm(0, sd = sdeps_phi)
  }

  for (i in 1:N) {
    for (t in 1:(T - 1)) {
      logit(phi[i, t]) <- muphi + beta_sex_phi[SEX[i]] + eps_phi[t]
      gamma[1, 1, i, t] <- phi[i, t]
      gamma[1, 2, i, t] <- 1 - phi[i, t]
      gamma[2, 1, i, t] <- 0
      gamma[2, 2, i, t] <- 1
    }
  }

  for (k in 1:K) {
    p[k] ~ dunif(0, 1)
  }

  for (i in 1:N) {
    omega[1, 1, i] <- 1 - p[SEX[i]]
    omega[1, 2, i] <- p[SEX[i]]
    omega[2, 1, i] <- 1
    omega[2, 2, i] <- 0
  }

  muphi ~ dnorm(0, sd = 1.5) # prior intercept on the logit scale
  sdeps_phi ~ dunif(0, 10) # prior standard deviation for the random effect

  for (i in 1:N) {
    z[i, first[i]] ~ dcat(delta[1:2])
    for (j in (first[i] + 1):T) {
      z[i, j] ~ dcat(gamma[z[i, j - 1], 1:2, i, j - 1])
      y[i, j] ~ dcat(omega[z[i, j], 1:2, i])
    }
  }
})
```

Setting the constants :

```{r}
my.constants <- list(N = N, T = T, first = first, SEX = SEX, K = K)                     
```

Initial values of the four Markov Chains :

```{r}
makeinits <- function() {
  list(
    p = runif(K, 0, 1),
    muphi = rnorm(1, 0, 1),
    sdeps_phi = runif(1, 0, 3),
    beta_sex_phi = rnorm(2, 0, 1.5),
    z = t(apply(y, 1, zinits))
  )
}

initial.values <- replicate(4, makeinits(), simplify = FALSE)
```

Parameters to monitor :

```{r}
params <- c("p", "muphi", "beta_sex_phi", "sdeps_phi", "eps_phi")
```

Running the MCMC :

```{r}
mcmc_p.sex_phi.timeRE.sex <- nimbleMCMC(
  code = hmm.p.sex_phi.timeRE.sex,
  constants = my.constants,
  data = my.data,
  inits = initial.values,
  monitors = params,
  niter = 20000,
  nburnin = 5000,
  nchains = 4,
  summary = TRUE,
  setSeed = chain_seeds,
  WAIC = TRUE
)
```

```{r}
mcmc_p.sex_phi.timeRE.sex$WAIC
```

## Model 6

|      | $p$         | $\phi$      |
|------|-------------|-------------|
| Time | constant    | continuous  |
| Sex  | categorical | categorical |

Model code :

```{r}
hmm.p.sex_phi.timeCONT.sex <- nimbleCode({
  delta[1] <- 1 # Pr(alive t = 1) = 1
  delta[2] <- 0 # Pr(dead t = 1) = 0

  beta_phi_sexe[1] <- 0
  for (s in 2:K) {
    beta_phi_sexe[s] ~ dnorm(0, sd = 1.5)
  }
  for (i in 1:N) {
    for (t in 1:(T - 1)) {
      logit(phi[i, t]) <- alpha_phi0 +
        beta_phi_sexe[SEX[i]] +
        beta_time * TIME[t]
      gamma[1, 1, i, t] <- phi[i, t] # alive -> alive
      gamma[1, 2, i, t] <- 1 - phi[i, t] # alive -> dead
      gamma[2, 1, i, t] <- 0 # dead  -> alive
      gamma[2, 2, i, t] <- 1 # dead  -> dead
    }
  }

  for (k in 1:K) {
    p[k] ~ dunif(0, 1)
  }

  for (i in 1:N) {
    omega[1, 1, i] <- 1 - p[SEX[i]]
    omega[1, 2, i] <- p[SEX[i]]
    omega[2, 1, i] <- 1
    omega[2, 2, i] <- 0
  }

  alpha_phi0 ~ dnorm(0, sd = 1.5) # survival intercept
  beta_time ~ dnorm(0, sd = 1.5) # prior intercept

  # likelihood
  for (i in 1:N) {
    z[i, first[i]] ~ dcat(delta[1:2])
    for (j in (first[i] + 1):T) {
      z[i, j] ~ dcat(gamma[z[i, j - 1], 1:2, i, j - 1])
      y[i, j] ~ dcat(omega[z[i, j], 1:2, i])
    }
  }
})
```

Setting the constants :

```{r}
my.constants <- list(N = N, T = T, first = first, SEX = SEX, K = K, TIME = TIME)                     
```

Initial values of the four Markov Chains :

```{r}
makeinits <- function() {
  list(
    p = runif(K, 0, 1),
    alpha_phi0 = rnorm(1, 0, 1),
    z = t(apply(y, 1, zinits)),
    beta_time = rnorm(1, 0, 1),
    beta_phi_sexe = c(0, rnorm(K - 1, 0, 0.5))
  )
}

initial.values <- replicate(4, makeinits(), simplify = FALSE)
```

Parameters to monitor :

```{r}
params <- c("p", "alpha_phi0", "beta_time", "beta_phi_sexe", "p", "phi")
```

Running the MCMC :

```{r}
mcmc_p.sex_phi.timeCONT.sex <- nimbleMCMC(
  code = hmm.p.sex_phi.timeCONT.sex,
  constants = my.constants,
  data = my.data,
  inits = initial.values,
  monitors = params,
  niter = 20000,
  nburnin = 5000,
  nchains = 4,
  summary = TRUE,
  setSeed = chain_seeds,
  WAIC = TRUE
)                                          
```

```{r}
mcmc_p.sex_phi.timeCONT.sex$WAIC
```

## Model 7

|      | $p$         | $\phi$      |
|------|-------------|-------------|
| Time | constant    | constant    |
| Sex  | categorical | categorical |

Model code :

```{r}
hmm.p.sex_phi.sex <- nimbleCode({
  delta[1] <- 1 # Pr(alive t = 1) = 1
  delta[2] <- 0 # Pr(dead t = 1) = 0

  for (k in 1:K) {
    phi[k] ~ dunif(0, 1)
    p[k] ~ dunif(0, 1)
  }

  for (i in 1:N) {
    gamma[1, 1, i] <- phi[SEX[i]] # alive -> alive
    gamma[1, 2, i] <- 1 - phi[SEX[i]] # alive -> dead
    gamma[2, 1, i] <- 0 # dead  -> alive
    gamma[2, 2, i] <- 1

    omega[1, 1, i] <- 1 - p[SEX[i]]
    omega[1, 2, i] <- p[SEX[i]]
    omega[2, 1, i] <- 1
    omega[2, 2, i] <- 0
  }

  # likelihood
  for (i in 1:N) {
    z[i, first[i]] ~ dcat(delta[1:2])
    for (j in (first[i] + 1):T) {
      z[i, j] ~ dcat(gamma[z[i, j - 1], 1:2, i])
      y[i, j] ~ dcat(omega[z[i, j], 1:2, i])
    }
  }
})
```

Setting the constants :

```{r}
my.constants <- list(N = N, T = T, first = first, SEX = SEX, K = K)
```

Initial values of the four Markov Chains :

```{r}
makeinits <- function() {
  list(
    p = runif(K, 0, 1),
    phi = runif(K, 0, 1),
    z = t(apply(y, 1, zinits))
  )
}

initial.values <- replicate(4, makeinits(), simplify = FALSE)
```

Parameters to monitor :

```{r}
params <- c("p", "phi")
```

Running the MCMC :

```{r}
mcmc_p.sex_phi.sex <- nimbleMCMC(
  code = hmm.p.sex_phi.sex,
  constants = my.constants,
  data = my.data,
  inits = initial.values,
  monitors = params,
  niter = 20000,
  nburnin = 5000,
  nchains = 4,
  summary = TRUE,
  setSeed = chain_seeds,
  WAIC = TRUE
)
```

```{r}
mcmc_p.sex_phi.sex$WAIC
```

## Model 8

|      | $p$         | $\phi$        |
|------|-------------|---------------|
| Time | constant    | random effect |
| Sex  | categorical | constant      |

Model code :

```{r}
hmm.p.sex_phi.sex <- nimbleCode({
  delta[1] <- 1 # Pr(alive t = 1) = 1
  delta[2] <- 0 # Pr(dead t = 1) = 0

  for (k in 1:K) {
    phi[k] ~ dunif(0, 1)
    p[k] ~ dunif(0, 1)
  }

  for (i in 1:N) {
    gamma[1, 1, i] <- phi[SEX[i]] # alive -> alive
    gamma[1, 2, i] <- 1 - phi[SEX[i]] # alive -> dead
    gamma[2, 1, i] <- 0 # dead  -> alive
    gamma[2, 2, i] <- 1

    omega[1, 1, i] <- 1 - p[SEX[i]]
    omega[1, 2, i] <- p[SEX[i]]
    omega[2, 1, i] <- 1
    omega[2, 2, i] <- 0
  }

  # likelihood
  for (i in 1:N) {
    z[i, first[i]] ~ dcat(delta[1:2])
    for (j in (first[i] + 1):T) {
      z[i, j] ~ dcat(gamma[z[i, j - 1], 1:2, i])
      y[i, j] ~ dcat(omega[z[i, j], 1:2, i])
    }
  }
})
```

Setting the constants :

```{r}
my.constants <- list(N = N, T = T, first = first, SEX = SEX, K = K)
```

Initial values of the four Markov Chains :

```{r}
makeinits <- function() {
  list(
    p = runif(K, 0, 1),
    muphi = rnorm(1, 0, 1),
    sdeps_phi = runif(1, 0, 3),
    z = t(apply(y, 1, zinits))
  )
}

initial.values <- replicate(4, makeinits(), simplify = FALSE)
```

Parameters to monitor :

```{r}
params <- c("p", "muphi", "sdeps_phi")
```

Running the MCMC :

```{r}
mcmc_p.sex_phi.sex <- nimbleMCMC(
  code = hmm.p.sex_phi.sex,
  constants = my.constants,
  data = my.data,
  inits = initial.values,
  monitors = params,
  niter = 20000,
  nburnin = 5000,
  nchains = 4,
  summary = TRUE,
  setSeed = chain_seeds,
  WAIC = TRUE
)
```

```{r}
mcmc_p.sex_phi.sex$WAIC
```

## Model 9

|      | $p$      | $\phi$   |
|------|----------|----------|
| Time | constant | constant |
| Sex  | constant | constant |

Model code :

```{r}
hmm.p._phi. <- nimbleCode({
  delta[1] <- 1
  delta[2] <- 0

  phi ~ dunif(0, 1)
  p ~ dunif(0, 1)

  omega[1, 1] <- 1 - p
  omega[1, 2] <- p
  omega[2, 1] <- 1
  omega[2, 2] <- 0
  gamma[1, 1] <- phi
  gamma[1, 2] <- 1 - phi
  gamma[2, 1] <- 0
  gamma[2, 2] <- 1

  for (i in 1:N) {
    z[i, first[i]] ~ dcat(delta[1:2])
    for (j in (first[i] + 1):T) {
      z[i, j] ~ dcat(gamma[z[i, j - 1], 1:2])
      y[i, j] ~ dcat(omega[z[i, j], 1:2])
    }
  }
})
```

Setting the constants :

```{r}
my.constants <- list(N = N, T = T, first = first)
```

Initial values of the four Markov Chains :

```{r}
makeinits <- function() {
  list(
    p = runif(1, 0, 1),
    phi = runif(1, 0, 1),
    z = t(apply(y, 1, zinits))
  )
}

initial.values <- replicate(4, makeinits(), simplify = FALSE)
```

Parameters to monitor :

```{r}
params <- c("p", "phi")
```

Running the MCMC :

```{r}
mcmc_p._phi. <- nimbleMCMC(
  code = hmm.p._phi.,
  constants = my.constants,
  data = my.data,
  inits = initial.values,
  monitors = params,
  niter = 20000,
  nburnin = 5000,
  nchains = 4,
  summary = TRUE,
  setSeed = chain_seeds,
  WAIC = TRUE
)
```

```{r}
mcmc_p._phi.$WAIC
```

## Summary WAIC

|         |            |             |               |                |           |
|:-------:|:----------:|:-----------:|:-------------:|:--------------:|:---------:|
| $Model$ | $p$ \~ sex | $p$ \~ time | $\phi$ \~ sex | $\phi$ \~ time |  $WAIC$   |
|    1    |    cat     |     cat     |      cat      |      cat       |    549    |
|    2    |    cat     |     RE      |      cat      |      cat       |    551    |
|    3    |    cat     |  constant   |      cat      |      cat       | **531\*** |
|    4    |  constant  |  constant   |      cat      |      cat       |    534    |
|    5    |    cat     |  constant   |      cat      |       RE       |    535    |
|    6    |    cat     |  constant   |      cat      |   continuous   |    536    |
|    7    |    cat     |  constant   |      cat      |    constant    |    538    |
|    8    |    cat     |  constant   |   constant    |       RE       | **533\*** |
|    9    |  constant  |  constant   |   constant    |    constant    |    541    |

cat = categorical ; RE = random effect

**\***Best models (2 models are considered equivalent if $\Delta$WAIC ≤ 2

We selected **model 8** for subsequent analyses because its WAIC is equivalent to that of model 3, but model 8 is more parsimonious.

# 2. Effect of oxychlordane (OXY)

## Encode oxy

Encoding $log(OXY)$ as a continuous variable (OXY) :

```{r}
log_oxy <- log(raw_data$oxy)
```

Encoding $log(OXY)$ as a categorical variable (OXYD) :

```{r}
quantiles <- quantile(log_oxy, probs = seq(0, 1, by = 0.1))

oxyd <- log_oxy |>
  cut(
    breaks = quantiles,
    labels = seq(1, 10, 1),
    include.lowest = TRUE
  ) |>
  as.numeric()
```

Pool all deciles except the last n :

```{r}
pool_n <- function(data, sex, n_female, n_male) {
  levels_d <- sort(unique(data))

  unique_d_female <- tail(levels_d, n_female)
  unique_d_male <- tail(levels_d, n_male)

  # 1 is male and 2 is female
  data[sex == 2 & !(data %in% unique_d_female)] <- 1
  data[sex == 1 & !(data %in% unique_d_male)] <- 1

  match(data, levels(factor(data)))
}
```

```{r}
data.frame(x = oxyd, sex = raw_data$sex, y = pool_n(oxyd, raw_data$sex, 2, 3))
```

## Model selection strategy

We will test the folowing models to compare them :

| Model | log(OXY)    | male threshold | female threshold | WAIC |
|-------|-------------|----------------|------------------|------|
| 1     | continuous  | na             | na               |      |
| 2     | categorical | 0              | 0                |      |
| 3     | categorical | 2              | 2                |      |
| 5     | categorical | 3              | 3                |      |
| 6     | categorical | 2              | 3                |      |

## Running the models : phi depends on OXY

### $log(OXY)$ as a continuous variable

Scale $log(OXY)$

```{r}
log_oxy_sc <- as.vector(scale(log_oxy))
sex <- as.integer(raw_data$sex)
G <- length(unique(oxyd))
```

```{r}
model_oxy_cont <- nimbleCode({
  delta[1] <- 1
  delta[2] <- 0
  
  for (k in 1:K) {
    p[k] ~ dunif(0, 1)
  }

  for (t in 1:(T - 1)) {
    eps_phi[t] ~ dnorm(0, sd = sdeps_phi)
  }

  for (i in 1:N) {
    for (t in 1:(T - 1)) {
      logit(phi[i, t]) <- muphi + eps_phi[t] + beta * oxy[i]

      gamma[1, 1, i, t] <- phi[i, t]
      gamma[1, 2, i, t] <- 1 - phi[i, t]
      gamma[2, 1, i, t] <- 0
      gamma[2, 2, i, t] <- 1
    }
  }


  for (i in 1:N) {
    omega[1, 1, i] <- 1 - p[sex[i]]
    omega[1, 2, i] <- p[sex[i]]
    omega[2, 1, i] <- 1
    omega[2, 2, i] <- 0
  }

  muphi ~ dnorm(0, sd = 1.5)
  sdeps_phi ~ dunif(0, 10)

  beta ~ dnorm(0, sd = 1.5)

  for (i in 1:N) {
    z[i, first[i]] ~ dcat(delta[1:2])
    for (j in (first[i] + 1):T) {
      z[i, j] ~ dcat(gamma[z[i, j - 1], 1:2, i, j - 1])
      y[i, j] ~ dcat(omega[z[i, j], 1:2, i])
    }
  }
})
```

```{r}
constants <- list(
  N = N,
  T = T,
  sex = sex,
  K = K,
  first = first,
  oxy = log_oxy_sc
)
```

```{r}
get_init_vals <- function() {
  list(
    beta = rnorm(1, 0, sd = 1.5),
    p = runif(K-1, 0, 1),
    z = t(apply(y, 1, zinits))
  )
}

initial_values <- rep(get_init_vals(), 4)
```

```{r}
monitor = c("p", "phi", "beta")
```

```{r}
mcmc_1 <- nimbleMCMC(
  code = model_oxy_cont,
  constants = constants,
  data = my.data,
  inits = initial_values,
  monitors = monitor,
  niter = n_iter,
  nburnin = n_burnin,
  nchains = n_chains,
  setSeed = chain_seeds,
  summary = TRUE,
  WAIC = TRUE
)
```

```{r}
MCMCsummary(mcmc_1$samples, params = "beta")
mcmc_1$WAIC
```

## $log(OXY)$ as a categorical variable

```{r}
model_oxy_cat <- nimbleCode({
  delta[1] <- 1
  delta[2] <- 0
  
    for (k in 1:K) {
    p[k] ~ dunif(0, 1)
  }

  for (t in 1:(T - 1)) {
    eps_phi[t] ~ dnorm(0, sd = sdeps_phi)
  }

  beta[1] <- 0
  for (g in 2:G) {
    beta[g] ~ dnorm(0, sd = 1.5)
  }

  for (i in 1:N) {
    for (t in 1:(T - 1)) {
      logit(phi[i, t]) <- muphi +
        eps_phi[t] +
        beta[oxyd[i]]

      gamma[1, 1, i, t] <- phi[i, t]
      gamma[1, 2, i, t] <- 1 - phi[i, t]
      gamma[2, 1, i, t] <- 0
      gamma[2, 2, i, t] <- 1
    }
  }

  for (i in 1:N) {
    omega[1, 1, i] <- 1 - p[sex[i]]
    omega[1, 2, i] <- p[sex[i]]
    omega[2, 1, i] <- 1
    omega[2, 2, i] <- 0
  }

  muphi ~ dnorm(0, sd = 1.5)
  sdeps_phi ~ dunif(0, 10)

  for (i in 1:N) {
    z[i, first[i]] ~ dcat(delta[1:2])
    for (j in (first[i] + 1):T) {
      z[i, j] ~ dcat(gamma[z[i, j - 1], 1:2, i, j - 1])
      y[i, j] ~ dcat(omega[z[i, j], 1:2, i])
    }
  }
})
```

```{r}
constants <- list(
  N = N,
  T = T,
  sex = sex,
  K = K,
  G = G,
  first = first,
  oxyd = oxyd
)
```

```{r}
get_init_vals <- function(data) {
  list(
    beta = c(0, rnorm(G-1, 0, 1.5)),
    p = runif(K-1, 0, 1),
    z = t(apply(y, 1, zinits))
  )
}

initial_values <- rep(get_init_vals(oxyd), 4)
```

```{r}
monitor = c("p", "phi", "beta")
```

```{r}
mcmc_2 <- nimbleMCMC(
  code = model_oxy_cat,
  constants = constants,
  data = my.data,
  inits = initial_values,
  monitors = monitor,
  niter = n_iter,
  nburnin = n_burnin,
  nchains = n_chains,
  setSeed = chain_seeds,
  summary = TRUE,
  WAIC = TRUE
)
```

```{r}
MCMCsummary(mcmc_2$samples, params = "beta")
mcmc_2$WAIC
```

## $log(OXY)$ as a pooled categorical variable (except last two deciles)

```{r}
oxyd_2D <- pool_n(oxyd, raw_data$sex, 2, 2)
G <- length(unique(oxyd_2D))
```

```{r}
constants <- list(
  N = N,
  T = T,
  sex = sex,
  K = K,
  G = G,
  first = first,
  oxyd = oxyd_2D
)
```

```{r}
initial_values <- rep(get_init_vals(oxyd_2D), 4)
```

```{r}
mcmc_3 <- nimbleMCMC(
  code = model_oxy_cat,
  constants = constants,
  data = data,
  inits = initial_values,
  monitors = monitor,
  niter = n_iter,
  nburnin = n_burnin,
  nchains = n_chains,
  setSeed = chain_seed,
  summary = TRUE,
  WAIC = TRUE
)
```

```{r}
MCMCsummary(mcmc_3$samples, params = "beta")
mcmc_3$WAIC
```

## $log(OXY)$ as a pooled categorical variable (except last three deciles)

```{r}
oxyd_3D <- pool_n(oxyd, raw_data$sex, 3, 3)
G <- length(unique(oxyd_3D))
```

```{r}
constants <- list(
  N = N,
  T = T,
  sex = sex,
  K = K,
  G = G,
  first = first,
  oxyd = oxyd_3D
)
```

```{r}
initial_values <- rep(get_init_vals(oxyd_3D), 4)
```

```{r}
mcmc_4 <- nimbleMCMC(
  code = model_oxy_cat,
  constants = constants,
  data = data,
  inits = initial_values,
  monitors = monitor,
  niter = n_iter,
  nburnin = n_burnin,
  nchains = n_chains,
  setSeed = chain_seeds,
  summary = TRUE,
  WAIC = TRUE
)
```

```{r}
MCMCsummary(mcmc_4$samples, params = "beta")
mcmc_4$WAIC
```

## $log(OXY)$ as a pooled categorical variable (except last two or three deciles depending on sex)

```{r}
oxyd_mf <- pool_n(oxyd, raw_data$sex, 2, 3)
G <- length(unique(oxyd_mf))
```

```{r}
model_oxy_cat_mf <- nimbleCode({
  delta[1] <- 1
  delta[2] <- 0
  
    for (k in 1:K) {
    p[k] ~ dunif(0, 1)
  }

  for (t in 1:(T - 1)) {
    eps_phi[t] ~ dnorm(0, sd = sdeps_phi)
  }

  beta[1,1] <- 0 # baseline (sex = 1 & class = 1)
  for (g in 2:G) {
    beta[1,g] ~ dnorm(0, sd = 1.5)
    beta[2,g] ~ dnorm(0, sd = 1.5)
  }

  for (i in 1:N) {
    for (t in 1:(T - 1)) {
      logit(phi[i, t]) <- muphi +
        eps_phi[t] +
        beta[sex[i], oxyd[i]]

      gamma[1, 1, i, t] <- phi[i, t]
      gamma[1, 2, i, t] <- 1 - phi[i, t]
      gamma[2, 1, i, t] <- 0
      gamma[2, 2, i, t] <- 1
    }
  }

  for (i in 1:N) {
    omega[1, 1, i] <- 1 - p[sex[i]]
    omega[1, 2, i] <- p[sex[i]]
    omega[2, 1, i] <- 1
    omega[2, 2, i] <- 0
  }

  muphi ~ dnorm(0, sd = 1.5)
  sdeps_phi ~ dunif(0, 10)

  for (i in 1:N) {
    z[i, first[i]] ~ dcat(delta[1:2])
    for (j in (first[i] + 1):T) {
      z[i, j] ~ dcat(gamma[z[i, j - 1], 1:2, i, j - 1])
      y[i, j] ~ dcat(omega[z[i, j], 1:2, i])
    }
  }
})
```

```{r}
constants <- list(
  N = N,
  T = T,
  sex = sex,
  K = K,
  G = G,
  first = first,
  oxyd = oxyd_mf
)
```

```{r}
makeinits <- function() {
  list(
    beta = {
      beta_matrix <- matrix(0, nrow = K, ncol = G)
      beta_matrix[1,2:G] <- rnorm(G-1,0,1)
      beta_matrix[2,1:G] <- rnorm(G,0,1)
      beta_matrix
    },
    p = runif(K-1,0,1),
    muphi = rnorm(1,0,1),
    sdeps_phi = rnorm(1,0,3),
    
    z = t(apply(y, 1, zinits))
  )
}

initial.values <- replicate(4, makeinits(), simplify = FALSE)
```

```{r}
mcmc_5 <- nimbleMCMC(
  code = model_oxy_cat_mf,
  constants = constants,
  data = data,
  inits = initial_values,
  monitors = monitor,
  niter = n_iter,
  nburnin = n_burnin,
  nchains = n_chains,
  setSeed = chain_seeds,
  summary = TRUE,
  WAIC = TRUE
)
```

```{r}
MCMCsummary(mcmc_5$samples, params = "beta")
mcmc_5$WAIC
```
