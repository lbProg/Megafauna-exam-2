---
title: "Capture-Mark-Recapture models of _Larus hyperboreus_"
author: 
    - Lucien Bastin
    - Lucie Fournil
date: 2025-09-17
format: html
knitr:
    opts_chunk:
        message: FALSE
        warning: FALSE
embed-resources: TRUE
lightbox: TRUE
toc: TRUE
toc-location: right-body
df-print: kable
---

# Setup

## Libraries

```{r}
library(dplyr)
library(ggplot2)
library(here)
library(MCMCvis)
library(nimble)
```

## Data

```{r}
raw_data <- read.csv(here("Data/input.csv"))
```

For reproducibility, we set the global seed and the seeds for each of the chains in our models.

```{r}
set.seed(1604)
chain_seed <- c(1, 2, 3, 4)
```

Fetching the CMR data :

```{r}
y <- raw_data |>
    select(x97:x04)

first <- apply(y, 1, function(x) min(which(x != 0)))
n_obs <- sum(apply(y, 1, sum) != 0)

for (i in 1:n_obs) {
  if (first[i] > 1) y[i, 1:(first[i] - 1)] <- NA
}
```

Converting CMR data from 0-1 to 1-2 and storing sex in a vector :

```{r}
data <- list(y = y + 1)
sex <- as.integer(raw_data$sex)
k <- max(sex)
```

```{r}
zinits <- function(y) {
  T <- length(y)
  first <- min(which(y != 0))
  last <- max(which(y == 1))
  z <- rep(NA, T)
  if (last == T) {
    z[first:T] <- 1
  } else {
    if (last == (T - 1)) {
      z[first:(T - 1)] <- 1
      z[T] <- sample(1:2, size = 1)
    } else {
      death <- sample((last + 1):T, size = 1)
      z[first:(death - 1)] <- 1
      z[death:T] <- 2
    }
  }
  return(z)
}
```

Global MCMC parameters :

```{r}
n_iter <- 200
n_burnin <- 100
n_chains <- 4
n_thin <- 1
```

# 1. Preliminary analyses

Selecting a model where survival probabliity and detection probability depend on time and sex. We will compare WAIC values to select the best model.

From the modt complex model to the most simple.

## Model 1

|      | $p$         | $\phi$      |
|------|-------------|-------------|
| Time | constant    | RE          |
| Sex  | categorical | categorical |

Model code :

```{r}
model <- nimbleCode({
  delta[1] <- 1
  delta[2] <- 0

  alpha_sex_phi[1] <- 0
  for (k in 1:K) {
    alpha_sex_phi[k] ~ dnorm(0, sd = 1.5)
  }
  for (t in 1:(T - 1)) {
    eps_phi[t] ~ dnorm(0, sd = sdeps_phi)
  }

  for (i in 1:N) {
    for (t in 1:(T - 1)) {
      logit(phi[i, t]) <- muphi + alpha_sex_phi[sex[i]] + eps_phi[t]
      gamma[1, 1, i, t] <- phi[i, t]
      gamma[1, 2, i, t] <- 1 - phi[i, t]
      gamma[2, 1, i, t] <- 0
      gamma[2, 2, i, t] <- 1
    }
  }

  for (k in 1:k) {
    p[k] ~ dunif(0, 1)
  }

  for (i in 1:N) {
    omega[1, 1, i] <- 1 - p[sex[i]]
    omega[1, 2, i] <- p[sex[i]]
    omega[2, 1, i] <- 1
    omega[2, 2, i] <- 0
  }

  for (i in 1:N) {
    z[i, first[i]] ~ dcat(delta[1:2])
    for (j in (first[i] + 1):T) {
      z[i, j] ~ dcat(gamma[z[i, j - 1], 1:2, i, j - 1])
      y[i, j] ~ dcat(omega[z[i, j], 1:2, i])
    }
  }
})
```

Setting the constants :

```{r}
constants <- list(
  N = nrow(y),
  T = ncol(y),
  first = first,
  sex = sex,
  K = max(sex)
)
```

Initial values of the four Markov Chains :

```{r}
get_init_vals <- function() {
  list(
    p = runif(K, 0, 1),
    muphi = rnorm(1, 0, 1),
    sdeps_phi = runif(1, 0, 3),
    alpha_sex_phi = c(0, runif(1, 0, 3)),
    z = t(apply(y, 1, zinits))
  )
}

initial_values <- rep(get_init_vals(), 4)
```

Parameters to monitor :

```{r}
params <- c("p", "muphi", "alpha_sex_phi", "sdeps_phi")
```

Running the MCMC :

```{r}
mcmc <- nimbleMCMC(
  code = model,
  constants = constants,
  data = data,
  inits = initial_values,
  monitors = params,
  niter = n_iter,
  nburnin = n_burnin,
  nchains = n_chains,
  setSeed = chain_seed,
  summary = TRUE,
  WAIC = TRUE
)
```

```{r}
mcmc$WAIC
mcmc$summary
```

```{r}
MCMCsummary(mcmc$samples, params = "p")
```

# 2. Effect of oxychlordane (OXY)

## Encode oxy

Encoding $log(OXY)$ as a continuous variable (OXY) :

```{r}
log_oxy <- log(raw_data$oxy)
```

Encoding $log(OXY)$ as a categorical variable (OXYD) :

```{r}
quantiles <- quantile(log_oxy, probs = seq(0, 1, by = 0.1))

oxyd <- log_oxy |>
  cut(
    breaks = quantiles,
    labels = seq(1, 10, 1),
    include.lowest = TRUE
  ) |>
  as.numeric()
```

Pool all deciles except the last n :

```{r}
pool_n <- function(data, sex, n_female, n_male) {
  levels_d <- sort(unique(data))

  unique_d_female <- tail(levels_d, n_female)
  unique_d_male <- tail(levels_d, n_male)

  # 1 is male and 2 is female
  data[sex == 2 & !(data %in% unique_d_female)] <- 1
  data[sex == 1 & !(data %in% unique_d_male)] <- 1

  match(data, levels(factor(data)))
}
```

```{r}
data.frame(x = oxyd, sex = raw_data$sex, y = pool_n(oxyd, raw_data$sex, 2, 3))
```

## Model selection strategy

We will test the folowing models to compare them :

| Model | log(OXY)    | male threshold | female threshold | WAIC |
|-------|-------------|----------------|------------------|------|
| 1     | continuous  | na             | na               |      |
| 2     | categorical | 0              | 0                |      |
| 3     | categorical | 2              | 2                |      |
| 5     | categorical | 3              | 3                |      |
| 6     | categorical | 2              | 3                |      |

## Running the models : phi depends on OXY

### log(OXY) as a continuous variable

Scale $log(OXY)$

```{r}
log_oxy_sc <- as.vector(scale(log_oxy))
```

```{r}
model_oxy_cont <- nimbleCode({
  delta[1] <- 1
  delta[2] <- 0

  for (t in 1:(T - 1)) {
    eps_phi[t] ~ dnorm(0, sd = sdeps_phi)
  }

  for (i in 1:N) {
    for (t in 1:(T - 1)) {
      logit(phi[i, t]) <- muphi + eps_phi[t] + beta * oxy[i]

      gamma[1, 1, i, t] <- phi[i, t]
      gamma[1, 2, i, t] <- 1 - phi[i, t]
      gamma[2, 1, i, t] <- 0
      gamma[2, 2, i, t] <- 1
    }
  }

  for (k in 1:K) {
    p[k] ~ dunif(0, 1)
  }

  for (i in 1:N) {
    omega[1, 1, i] <- 1 - p[sex[i]]
    omega[1, 2, i] <- p[sex[i]]
    omega[2, 1, i] <- 1
    omega[2, 2, i] <- 0
  }

  muphi ~ dnorm(0, sd = 1.5)
  sdeps_phi ~ dunif(0, 10)

  beta ~ dnorm(0, sd = 1.5)

  for (i in 1:N) {
    z[i, first[i]] ~ dcat(delta[1:2])
    for (j in (first[i] + 1):T) {
      z[i, j] ~ dcat(gamma[z[i, j - 1], 1:2, i, j - 1])
      y[i, j] ~ dcat(omega[z[i, j], 1:2, i])
    }
  }
})
```

```{r}
constants <- list(
  N = nrow(y),
  T = ncol(y),
  sex = sex,
  K = max(sex),
  first = first,
  oxy = log_oxy_sc
)
```

```{r}
initial_values <- function() {
  list(
    beta = rnorm(1, 0, 1),
    p = runif(2, 0, 1),
    z = t(apply(y, 1, zinits))
  )
}
```

```{r}
monitor = c("p", "phi", "beta")
```

```{r}
mcmc_1 <- nimbleMCMC(
  code = model_oxy_cont,
  constants = constants,
  data = data,
  inits = initial_values,
  monitors = monitor,
  niter = n_iter,
  nburnin = n_burnin,
  nchains = n_chains,
  summary = TRUE,
  WAIC = TRUE
)
```

```{r}
MCMCsummary(mcmc_1$samples, params = "beta")
mcmc_1$WAIC
```

## $log(OXY)$ as a categorical variable

```{r}
model_oxy_cat <- nimbleCode({
  delta[1] <- 1
  delta[2] <- 0

  for (t in 1:(T - 1)) {
    eps_phi[t] ~ dnorm(0, sd = sdeps_phi)
  }

  for (i in 1:length(unique(oxyd))) {
    beta[i] ~ dnorm(0, 1.5)
  }

  for (i in 1:N) {
    for (t in 1:(T - 1)) {
      logit(phi[i, t]) <- muphi +
        eps_phi[t] +
        beta[oxyd[i]]

      gamma[1, 1, i, t] <- phi[i, t]
      gamma[1, 2, i, t] <- 1 - phi[i, t]
      gamma[2, 1, i, t] <- 0
      gamma[2, 2, i, t] <- 1
    }
  }

  for (k in 1:K) {
    p[k] ~ dunif(0, 1)
  }

  for (i in 1:N) {
    omega[1, 1, i] <- 1 - p[sex[i]]
    omega[1, 2, i] <- p[sex[i]]
    omega[2, 1, i] <- 1
    omega[2, 2, i] <- 0
  }

  muphi ~ dnorm(0, sd = 1.5)
  sdeps_phi ~ dunif(0, 10)

  for (i in 1:N) {
    z[i, first[i]] ~ dcat(delta[1:2])
    for (j in (first[i] + 1):T) {
      z[i, j] ~ dcat(gamma[z[i, j - 1], 1:2, i, j - 1])
      y[i, j] ~ dcat(omega[z[i, j], 1:2, i])
    }
  }
})
```

```{r}
constants <- list(
  N = nrow(y),
  T = ncol(y),
  sex = sex,
  K = max(sex),
  first = first,
  oxyd = oxyd
)
```

```{r}
initial_values <- function() {
  list(
    beta = rnorm(length(unique(oxyd)), 0, 1),
    p = runif(2, 0, 1),
    z = t(apply(y, 1, zinits))
  )
}
```

```{r}
monitor = c("p", "phi", "beta")
```

```{r}
mcmc_2 <- nimbleMCMC(
  code = model_oxy_cat,
  constants = constants,
  data = data,
  inits = initial_values,
  monitors = monitor,
  niter = n_iter,
  nburnin = n_burnin,
  nchains = n_chains,
  summary = TRUE,
  WAIC = TRUE
)
```

```{r}
MCMCsummary(mcmc_2$samples, params = "beta")
mcmc_2$WAIC
```

## $log(OXY)$ as a pooled categorical variable (except last two deciles)

```{r}
oxyd_2D <- pool_n(oxyd, raw_data$sex, 2, 2)
```

```{r}
constants <- list(
  N = nrow(y),
  T = ncol(y),
  sex = sex,
  K = max(sex),
  first = first,
  oxyd = oxyd_2D
)
```

```{r}
initial_values <- function() {
  list(
    beta = rnorm(length(unique(oxyd_2D)), 0, 1),
    p = runif(2, 0, 1),
    z = t(apply(y, 1, zinits))
  )
}
```

```{r}
mcmc_3 <- nimbleMCMC(
  code = model_oxy_cat,
  constants = constants,
  data = data,
  inits = initial_values,
  monitors = monitor,
  niter = n_iter,
  nburnin = n_burnin,
  nchains = n_chains,
  summary = TRUE,
  WAIC = TRUE
)
```

```{r}
MCMCsummary(mcmc_3$samples, params = "beta")
mcmc_3$WAIC
```

## $log(OXY)$ as a pooled categorical variable (except last three deciles)

```{r}
oxyd_3D <- pool_n(oxyd, raw_data$sex, 3, 3)
```

```{r}
constants <- list(
  N = nrow(y),
  T = ncol(y),
  sex = sex,
  K = max(sex),
  first = first,
  oxyd = oxyd_3D
)
```

```{r}
initial_values <- function() {
  list(
    beta = rnorm(length(unique(oxyd_3D)), 0, 1),
    p = runif(2, 0, 1),
    z = t(apply(y, 1, zinits))
  )
}
```

```{r}
mcmc_4 <- nimbleMCMC(
  code = model_oxy_cat,
  constants = constants,
  data = data,
  inits = initial_values,
  monitors = monitor,
  niter = n_iter,
  nburnin = n_burnin,
  nchains = n_chains,
  summary = TRUE,
  WAIC = TRUE
)
```

```{r}
MCMCsummary(mcmc_4$samples, params = "beta")
mcmc_4$WAIC
```

## $log(OXY)$ as a pooled categorical variable (except last two or three deciles depending on sex)

```{r}
oxyd_mf <- pool_n(oxyd, raw_data$sex, 2, 3)
```

```{r}
constants <- list(
  N = nrow(y),
  T = ncol(y),
  sex = sex,
  K = max(sex),
  first = first,
  oxyd = oxyd_mf
)
```

```{r}
initial_values <- function() {
  list(
    beta = rnorm(length(unique(oxyd_mf)), 0, 1),
    p = runif(2, 0, 1),
    z = t(apply(y, 1, zinits))
  )
}
```

```{r}
mcmc_5 <- nimbleMCMC(
  code = model_oxy_cat,
  constants = constants,
  data = data,
  inits = initial_values,
  monitors = monitor,
  niter = n_iter,
  nburnin = n_burnin,
  nchains = n_chains,
  summary = TRUE,
  WAIC = TRUE
)
```

```{r}
MCMCsummary(mcmc_5$samples, params = "beta")
mcmc_5$WAIC
```