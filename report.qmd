---
title: "Capture-Mark-Recapture models of _Larus hyperboreus_"
author: 
    - Lucien Bastin
    - Lucie Fournil
date: 2025-09-17
format: html
knitr:
    opts_chunk:
        message: FALSE
        warning: FALSE
embed-resources: TRUE
lightbox: TRUE
toc: TRUE
toc-location: right-body
df-print: kable
---

# Setup

## Libraries

```{r}
library(dplyr)
library(ggplot2)
library(here)
library(MCMCvis)
library(nimble)
```

## Data

```{r}
raw_data <- read.csv(here("Data/input.csv"))
```

```{r}
set.seed(1604)
```

```{r}
y <- raw_data |>
    select(x97:x04)

# time_span <- ncol(y)

first <- apply(y, 1, function(x) min(which(x != 0)))
n_obs <- sum(apply(y, 1, sum) != 0)

for (i in 1:n_obs) { # Not useful i think
  if (first[i] > 1) y[i, 1:(first[i] - 1)] <- NA
}
```

```{r}
data <- list(y = y + 1)
```

```{r}
zinits <- function(y) {
  T <- length(y)
  first <- min(which(y != 0))
  last <- max(which(y == 1))
  z <- rep(NA, T)
  if (last == T) {
    z[first:T] <- 1
  } else {
    if (last == (T - 1)) {
      z[first:(T - 1)] <- 1
      z[T] <- sample(1:2, size = 1)
    } else {
      death <- sample((last + 1):T, size = 1)
      z[first:(death - 1)] <- 1
      z[death:T] <- 2
    }
  }
  return(z)
}
```

Global model parameters :

```{r}
n_iter <- 200
n_burnin <- 100
n_chains <- 2
n_thin <- 1
```

# 1. Preliminary analyses

Selecting a model where survival probabliity and detection probability depend on time and sex. We will compare WAIC values to select the best model.

From the modt complex model to the most simple.

## Model 1 : $p$ and $\phi$ depend on time and sex as categorical variables

```{r}
model_1 <- nimbleCode({
  for (i in 1:N) {
    for (j in 1:T) {
      phi[i, j] ~ dunif(0, 1)
      p[i, j] ~ dunif(0, 1)

      gamma[1, 1, i, j] <- phi[sex[i], j]
      gamma[1, 2, i, j] <- 1 - phi[sex[i], j]
      gamma[2, 1, i, j] <- 0
      gamma[2, 2, i, j] <- 1

      omega[1, 1, i, j] <- 1 - p[sex[i], j]
      omega[1, 2, i, j] <- p[sex[i], j]
      omega[2, 1, i, j] <- 1
      omega[2, 2, i, j] <- 0
    }
  }

  delta[1] <- 1
  delta[2] <- 0

  for (i in 1:N) {
    z[i, first[i]] ~ dcat(delta[1:2])
    for (j in (first[i] + 1):T) {
      z[i, j] ~ dcat(gamma[z[i, j - 1], 1:2, i, j - 1])
      y[i, j] ~ dcat(omega[z[i, j], 1:2, i, j - 1])
    }
  }
})
```

```{r}
constants <- list(N = nrow(y), T = ncol(y), sex = raw_data$sex, first = first)
```

```{r}
initial_values1 <- list(
  z = t(apply(y, 1, zinits))
)

initial_values2 <- list(
  z = t(apply(y, 1, zinits))
)

initial_values <- c(initial_values1, initial_values2)
```

```{r}
monitor <- c("phi", "p")
```

```{r}
mcmc_1 <- nimbleMCMC(
  code = model_1,
  constants = constants,
  data = data,
  inits = initial_values,
  monitors = monitor,
  niter = n_iter,
  nburnin = n_burnin,
  nchains = n_chains,
  thin = n_thin,
  WAIC = TRUE,
  summary = TRUE
)
```

```{r}
mcmc_1$WAIC
```

# 2. Effect of oxychlordane (OXY)

## Encode oxy

log(OXY) as a continuous variable (OXY) :

```{r}
log_oxy <- log(raw_data$oxy)
```

log(OXY) as a categorical variable (OXYD) :

```{r}
quantiles <- quantile(log_oxy, probs = seq(0, 1, by = 0.1))

oxyd <- log_oxy |>
  cut(
    breaks = quantiles,
    labels = paste0(rep(seq(1, 10, 1)), rep("D", 10)),
    include.lowest = TRUE
  )
```

Pool all deciles except the last n :

```{r}
pool_n <- function(data, sex, n_female, n_male) {
  levels_d <- sort(unique(data))

  unique_d_female <- tail(levels_d, n_female)
  unique_d_male <- tail(levels_d, n_male)

  data <- as.character(data)

  # 1 is male and 2 is female
  data[sex == 2 & !(data %in% unique_d_female)] <- "group_D"
  data[sex == 1 & !(data %in% unique_d_male)] <- "group_D"

  data
}
```

```{r}
data.frame(x = oxyd, sex = raw_data$sex, y = pool_n(oxyd, raw_data$sex, 2, 3))
```

## Model selection strategy

| Model | log(OXY)    | male threshold | female threshold | WAIC |
|-------|-------------|----------------|------------------|------|
| 1     | continuous  | na             | na               |      |
| 2     | categorical | 0              | 0                |      |
| 3     | categorical | 2              | 2                |      |
| 4     | categorical | 3              | 3                |      |
| 5     | categorical | 2              | 3                |      |

## Running the models : phi depends on OXY

### log(OXY) as a continuous variable

Scale log(OXY)

```{r}
log_oxy_sc <- as.vector(scale(log_oxy))
```

```{r}
model_oxy_cont <- nimbleCode({
  p ~ dunif(0, 1)

  omega[1, 1] <- 1 - p
  omega[1, 2] <- p
  omega[2, 1] <- 1
  omega[2, 2] <- 0

  for (i in 1:N) {
    logit(phi[i]) <- beta[1] + beta[2] * oxy[i]
    gamma[1, 1, i] <- phi[i]
    gamma[1, 2, i] <- 1 - phi[i]
    gamma[2, 1, i] <- 0
    gamma[2, 2, i] <- 1
  }

  beta[1] ~ dnorm(mean = 0, sd = 1.5)
  beta[2] ~ dnorm(mean = 0, sd = 1.5)

  delta[1] <- 1
  delta[2] <- 0

  for (i in 1:N) {
    z[i, first[i]] ~ dcat(delta[1:2])
    for (j in (first[i] + 1):T) {
      z[i, j] ~ dcat(gamma[z[i, j - 1], 1:2, i])
      y[i, j] ~ dcat(omega[z[i, j], 1:2])
    }
  }
})
```

```{r}
constants <- list(
  N = nrow(y),
  T = ncol(y),
  first = first,
  oxy = log_oxy_sc
)
```

```{r}
initial_values <- function() {
  list(
    beta = rnorm(2, 0, 1),
    p = runif(1, 0, 1),
    z = t(apply(y, 1, zinits))
  )
}
```

```{r}
monitor = c("p", "phi", "beta")
```

```{r}
mcmc_1 <- nimbleMCMC(
  code = model_oxy_cont,
  constants = constants,
  data = data,
  inits = initial_values,
  monitors = monitor,
  niter = n_iter,
  nburnin = n_burnin,
  nchains = n_chains,
  summary = TRUE,
  WAIC = TRUE
)
```