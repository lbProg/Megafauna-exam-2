---
title: "Capture-Mark-Recapture models of _Larus hyperboreus_"
author: 
    - Lucien Bastin
    - Lucie Fournil
date: 2025-09-17
format: html
knitr:
    opts_chunk:
        message: FALSE
        warning: FALSE
        eval: FALSE
embed-resources: TRUE
lightbox: TRUE
toc: TRUE
toc-location: right-body
df-print: kable
---

# Setup

## Libraries

```{r}
#| eval: true

library(dplyr)
library(ggplot2)
library(here)
library(MCMCvis)
library(nimble)
```

## Data

```{r}
#| eval: true
#| echo: false

load(here("Data/Models_part1_seed1604_VF.RData"))
load(here("Data/Models_part2_seed1604_VF.RData"))
```

```{r}
raw_data <- read.csv(here("Data/input.csv"))
```

For reproducibility, we set the global seed and the seeds for each of the chains in our models.

```{r}
set.seed(1604)
chain_seeds <- c(1, 2, 3, 4)
```

Fetching the CMR data :

```{r}
y <- raw_data |>
    select(x97:x04) |>
    as.matrix()

first <- apply(y, 1, function(x) min(which(x != 0)))
n_obs <- sum(apply(y, 1, sum) != 0)

for (i in 1:n_obs) {
  if (first[i] > 1) y[i, 1:(first[i] - 1)] <- NA
}
```

Converting CMR data from 0-1 to 1-2 and storing sex in a vector :

```{r}
my.data <- list(y = y + 1)
SEX <- as.integer(raw_data$sex)
K <- length(unique(SEX))
N <- nrow(y)
T <- ncol(y)
TIME <- c(1, 2, 3, 4, 5, 6, 7, 8)
TIME <- as.numeric(scale(TIME))
```

```{r}
zinits <- function(y) {
  T <- length(y)
  first <- min(which(y != 0))
  last <- max(which(y == 1))
  z <- rep(NA, T)
  if (last == T) {
    z[first:T] <- 1
  } else {
    if (last == (T - 1)) {
      z[first:(T - 1)] <- 1
      z[T] <- sample(1:2, size = 1)
    } else {
      death <- sample((last + 1):T, size = 1)
      z[first:(death - 1)] <- 1
      z[death:T] <- 2
    }
  }
  return(z)
}
```

Global MCMC parameters :

```{r}
n_iter <- 20000
n_burnin <- 5000
n_chains <- 4
n_thin <- 1
```

## NB : Categorical effects

In all our models with *categorical effects*, we set the *first category to 0* (reference) to interpret each coefficient as the *difference (on the logit scale)* relative to this reference.

# 1. Preliminary analyses

Selecting a model where survival probability and detection probability depend on time and sex. We will compare WAIC values to select the best model.

From the most simple model to the most complex.

## Comparison of temporal structures for p

### Model 1

|      | $p$      | $\phi$   |
|------|----------|----------|
| Time | constant | constant |
| Sex  | constant | constant |

Parsimonious null model ($p$ and $\phi$ constant). Used as a reference to assess the relevance of temporal and/or sex effects.

Model code :

```{r}
hmm.p._phi. <- nimbleCode({
  delta[1] <- 1
  delta[2] <- 0

  phi ~ dunif(0, 1)
  omega[1, 1] <- 1 - p
  omega[1, 2] <- p
  omega[2, 1] <- 1
  omega[2, 2] <- 0

  p ~ dunif(0, 1)
  gamma[1, 1] <- phi
  gamma[1, 2] <- 1 - phi
  gamma[2, 1] <- 0
  gamma[2, 2] <- 1

  for (i in 1:N) {
    z[i, first[i]] ~ dcat(delta[1:2])
    for (j in (first[i] + 1):T) {
      z[i, j] ~ dcat(gamma[z[i, j - 1], 1:2])
      y[i, j] ~ dcat(omega[z[i, j], 1:2])
    }
  }
})
```

Setting the constants :

```{r}
my.constants <- list(
  N = N,
  T = T,
  first = first
)
```

Initial values of the four Markov Chains :

```{r}
makeinits <- function() {
  list(
    p = runif(1, 0, 1),
    phi = runif(1, 0, 1),
    z = t(apply(y, 1, zinits))
  )
}

initial.values <- replicate(4, makeinits(), simplify = FALSE)
```

Parameters to monitor :

```{r}
params <- c("phi", "p")
```

Running the MCMC :

```{r}
mcmc_p._phi. <- nimbleMCMC(
  code = hmm.p._phi.,
  constants = my.constants,
  data = my.data,
  inits = initial.values,
  monitors = params,
  niter = n_iter,
  nburnin = n_burnin,
  nchains = n_chains,
  summary = TRUE,
  setSeed = chain_seeds,
  WAIC = TRUE
)
```

```{r}
#| eval: true

mcmc_p._phi.$WAIC
```

### Model 2

|      | $p$           | $\phi$   |
|------|---------------|----------|
| Time | random effect | constant |
| Sex  | constant      | constant |

Detection is expected to fluctuate randomly among years due to variable field conditions, protocols or different observers.

Model code :

```{r}
hmm.p.timeRE_phi. <- nimbleCode({
  delta[1] <- 1
  delta[2] <- 0

  for (t in 1:(T - 1)) {
    logit(p[t]) <- mup + eps_p[t]
    eps_p[t] ~ dnorm(0, sd = sdeps_p)
    omega[1, 1, t] <- 1 - p[t]
    omega[1, 2, t] <- p[t]
    omega[2, 1, t] <- 1
    omega[2, 2, t] <- 0
  }

  phi ~ dunif(0, 1)
  gamma[1, 1] <- phi
  gamma[1, 2] <- 1 - phi
  gamma[2, 1] <- 0
  gamma[2, 2] <- 1

  mup ~ dnorm(0, sd = 1.5)
  sdeps_p ~ dunif(0, 10)
  for (i in 1:N) {
    z[i, first[i]] ~ dcat(delta[1:2])
    for (j in (first[i] + 1):T) {
      z[i, j] ~ dcat(gamma[z[i, j - 1], 1:2])
      y[i, j] ~ dcat(omega[z[i, j], 1:2, j - 1])
    }
  }
})
```

Setting the constants :

```{r}
my.constants <- list(N = N, T = T, first = first)
```

Initial values of the four Markov Chains :

```{r}
makeinits <- function() {
  list(
    mup = rnorm(1, 0, 1),
    sdeps_p = runif(1, 0, 3),
    phi = runif(1, 0, 1),
    z = t(apply(y, 1, zinits))
  )
}

initial.values <- replicate(4, makeinits(), simplify = FALSE)
```

Parameters to monitor :

```{r}
params <- c("mup", "sdeps_p", "phi")
```

Running the MCMC :

```{r}
mcmc_p.timeRE_phi. <- nimbleMCMC(
  code = hmm.p.timeRE_phi.,
  constants = my.constants,
  data = my.data,
  inits = initial.values,
  monitors = params,
  niter = n_iter,
  nburnin = n_burnin,
  nchains = n_chains,
  summary = TRUE,
  setSeed = chain_seeds,
  WAIC = TRUE
)
```

```{r}
#| eval: true

mcmc_p.timeRE_phi.$WAIC
```

### Model 3

|      | $p$         | $\phi$   |
|------|-------------|----------|
| Time | categorical | constant |
| Sex  | constant    | constant |

Detection is expected to fluctuate in a non-linear way due to variable field conditions, protocols or different observers.

Model code :

```{r}
hmm.p.timeCAT_phi. <- nimbleCode({
  delta[1] <- 1
  delta[2] <- 0

  for (t in 1:(T - 1)) {
    p[t] ~ dunif(0, 1)
    omega[1, 1, t] <- 1 - p[t]
    omega[1, 2, t] <- p[t]
    omega[2, 1, t] <- 1
    omega[2, 2, t] <- 0
  }

  phi ~ dunif(0, 1)
  gamma[1, 1] <- phi
  gamma[1, 2] <- 1 - phi
  gamma[2, 1] <- 0
  gamma[2, 2] <- 1

  for (i in 1:N) {
    z[i, first[i]] ~ dcat(delta[1:2])
    for (j in (first[i] + 1):T) {
      z[i, j] ~ dcat(gamma[z[i, j - 1], 1:2])
      y[i, j] ~ dcat(omega[z[i, j], 1:2, j - 1])
    }
  }
})
```

Setting the constants :

```{r}
my.constants <- list(N = N, T = T, first = first)
```

Initial values of the four Markov Chains :

```{r}
makeinits <- function() {
  list(
    p = runif((T - 1), 0, 1),
    phi = runif(1, 0, 1),
    z = t(apply(y, 1, zinits))
  )
}

initial.values <- replicate(4, makeinits(), simplify = FALSE)
```

Parameters to monitor :

```{r}
params <- c("p", "phi")
```

Running the MCMC :

```{r}
mcmc_p.timeCAT_phi. <- nimbleMCMC(
  code = hmm.p.timeCAT_phi.,
  constants = my.constants,
  data = my.data,
  inits = initial.values,
  monitors = params,
  niter = n_iter,
  nburnin = n_burnin,
  nchains = 4,
  summary = TRUE,
  setSeed = chain_seeds,
  WAIC = TRUE
)
```

```{r}
#| eval: true

mcmc_p.timeCAT_phi.$WAIC
```

When examining the time-dependent parameter p, which was modeled as a categorical variable, we observed an apparent decline in detection probability over time (across the different categories). However, from a biological standpoint, we did not consider it particularly meaningful to model such a temporal decline.

### Summary WAIC

| Model | time          | WAIC |
|-------|---------------|------|
| 1     | constant      | 541  |
| 2     | random effect | 553  |
| 3     | categorical   | 557  |

The best model for time-dependent p was **model 1** (time constant), so we used this model as the basis for selecting the best model for $p$ that also included sex.

## Comparison of sex effect for p

### Model 4

|      | $p$         | $\phi$   |
|------|-------------|----------|
| Time | constant    | constant |
| Sex  | categorical | constant |

Behavioral differences between sexes can affect detectability.

Model code :

```{r}
hmm.p.sex_phi. <- nimbleCode({
  delta[1] <- 1
  delta[2] <- 0

  for (k in 1:K) {
    p[k] ~ dunif(0, 1)
  }

  for (i in 1:N) {
    omega[1, 1, i] <- 1 - p[SEX[i]]
    omega[1, 2, i] <- p[SEX[i]]
    omega[2, 1, i] <- 1
    omega[2, 2, i] <- 0
  }

  phi ~ dunif(0, 1)
  gamma[1, 1] <- phi
  gamma[1, 2] <- 1 - phi
  gamma[2, 1] <- 0
  gamma[2, 2] <- 1

  for (i in 1:N) {
    z[i, first[i]] ~ dcat(delta[1:2])
    for (j in (first[i] + 1):T) {
      z[i, j] ~ dcat(gamma[z[i, j - 1], 1:2])
      y[i, j] ~ dcat(omega[z[i, j], 1:2, i])
    }
  }
})
```

Setting the constants :

```{r}
my.constants <- list(N = N, T = T, first = first, SEX = SEX, K = K)
```

Initial values of the four Markov Chains :

```{r}
makeinits <- function() {
  list(
    p = runif(K, 0, 1),
    phi = runif(1, 0, 1),
    z = t(apply(y, 1, zinits))
  )
}

initial.values <- replicate(4, makeinits(), simplify = FALSE)
```

Parameters to monitor :

```{r}
params <- c("p", "phi")
```

Running the MCMC :

```{r}
mcmc_p.sex_phi. <- nimbleMCMC(
  code = hmm.p.sex_phi.,
  constants = my.constants,
  data = my.data,
  inits = initial.values,
  monitors = params,
  niter = n_iter,
  nburnin = n_burnin,
  nchains = 4,
  summary = TRUE,
  setSeed = chain_seeds,
  WAIC = TRUE
)                                      
```

```{r}
#| eval: true

mcmc_p.sex_phi.$WAIC
```

### Summary WAIC

| Model | sex         | WAIC |
|-------|-------------|------|
| 1     | constant    | 541  |
| 4     | categorical | 537  |

Since the best model for $p$ is **model 4** ($p$ depends only on sex as a categorical covariate), it was retained for selecting the best model for $\phi$.

## Comparison of temporal structures for phi

### Model 5

|      | $p$         | $\phi$        |
|------|-------------|---------------|
| Time | constant    | random effect |
| Sex  | categorical | constant      |

In a long-lived species, survival may fluctuate from year to year due to unobserved environmental factor. A yearly random effect captures this stochastic variability

Model code :

```{r}
hmm.p.sex_phi.timeRE <- nimbleCode({
  delta[1] <- 1          
  delta[2] <- 0 
  
  for(k in 1:K){
    p[k] ~ dunif(0,1)
  }
  
  for(i in 1:N){
    omega[1,1,i] <- 1 - p[SEX[i]]
    omega[1,2,i] <- p[SEX[i]]
    omega[2,1,i] <- 1
    omega[2,2,i] <- 0
  }
  
  for (t in 1:(T-1)){
    logit(phi[t]) <- muphi + eps_phi[t] 
    eps_phi[t] ~ dnorm(0, sd = sdeps_phi)
    gamma[1,1,t] <- phi[t]      
    gamma[1,2,t] <- 1 - phi[t]  
    gamma[2,1,t] <- 0           
    gamma[2,2,t] <- 1           
  }
  
  muphi ~ dnorm(0, sd = 1.5)
  sdeps_phi ~ dunif(0, 10)
  
  for(i in 1:N){
    z[i, first[i]] ~ dcat(delta[1:2])
    for(j in (first[i]+1):T){
      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2,j-1])
      y[i,j] ~ dcat(omega[z[i,j], 1:2,i])
    }
  }
})
```

Setting the constants :

```{r}
my.constants <- list(N = N, T = T, first = first, SEX = SEX, K = K)                     
```

Initial values of the four Markov Chains :

```{r}
makeinits <- function() {
  list(
    p = runif(K, 0, 1),
    muphi = rnorm(1, 0, 1),
    sdeps_phi = runif(1, 0, 3),
    z = t(apply(y, 1, zinits))
  )
}

initial.values <- replicate(4, makeinits(), simplify = FALSE)
```

Parameters to monitor :

```{r}
params <- c("p", "muphi", "sdeps_phi")
```

Running the MCMC :

```{r}
mcmc_p.sex_phi.timeRE <- nimbleMCMC(
  code = hmm.p.sex_phi.timeRE,
  constants = my.constants,
  data = my.data,
  inits = initial.values,
  monitors = params,
  niter = n_iter,
  nburnin = n_burnin,
  nchains = 4,
  summary = TRUE,
  setSeed = chain_seeds,
  WAIC = TRUE
)
```

```{r}
#| eval: true

mcmc_p.sex_phi.timeRE$WAIC
```

### Model 6

|      | $p$         | $\phi$      |
|------|-------------|-------------|
| Time | constant    | categorical |
| Sex  | categorical | constant    |

In a long-lived species, survival may fluctuate from year to year due to unobserved environmental factor.

Model code :

```{r}
hmm.p.sex_phi.timeCAT <- nimbleCode({
  delta[1] <- 1          
  delta[2] <- 0 
  
  for(k in 1:K){
    p[k] ~ dunif(0,1)
  }
  
  for(i in 1:N){
    omega[1,1,i] <- 1 - p[SEX[i]]
    omega[1,2,i] <- p[SEX[i]]
    omega[2,1,i] <- 1
    omega[2,2,i] <- 0
  }
  
  for(t in 1:(T-1)){
    phi[t] ~ dunif(0,1)   
    gamma[1,1,t] <- phi[t]
    gamma[1,2,t] <- 1 - phi[t]
    gamma[2,1,t] <- 0
    gamma[2,2,t] <- 1
  }

  
  for(i in 1:N){
    z[i, first[i]] ~ dcat(delta[1:2])
    for(j in (first[i]+1):T){
      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2,j-1])
      y[i,j] ~ dcat(omega[z[i,j], 1:2,i])
    }
  }
})

```

Setting the constants :

```{r}
my.constants <- list(N = N, T = T, first = first, SEX = SEX, K = K)
```

Initial values of the four Markov Chains :

```{r}
makeinits <- function() {
  list(
    p = runif(K, 0, 1),
    phi = runif(T - 1, 0, 1),
    z = t(apply(y, 1, zinits))
  )
}

initial.values <- replicate(4, makeinits(), simplify = FALSE)
```

Parameters to monitor :

```{r}
params <- c("p", "phi")
```

Running the MCMC :

```{r}
mcmc_p.sex_phi.timeCAT <- nimbleMCMC(
  code = hmm.p.sex_phi.timeCAT,
  constants = my.constants,
  data = my.data,
  inits = initial.values,
  monitors = params,
  niter = n_iter,
  nburnin = n_burnin,
  nchains = 4,
  summary = TRUE,
  setSeed = chain_seeds,
  WAIC = TRUE
)                                          
```

```{r}
#| eval: true

mcmc_p.sex_phi.timeCAT$WAIC
```

### Model 7

|      | $p$         | $\phi$     |
|------|-------------|------------|
| Time | constant    | continuous |
| Sex  | categorical | constant   |

Directional and cumulative pressures (such as chronic exposure to pollutants, habitat degradation, and climate change) can lead to a gradual yearly decline in survival.

Model code :

```{r}
hmm.p.sex_phi.timeCONT <- nimbleCode({
  delta[1] <- 1
  delta[2] <- 0

  for (k in 1:K) {
    p[k] ~ dunif(0, 1)
  }

  for (i in 1:N) {
    omega[1, 1, i] <- 1 - p[SEX[i]]
    omega[1, 2, i] <- p[SEX[i]]
    omega[2, 1, i] <- 1
    omega[2, 2, i] <- 0
  }

  for (t in 1:(T - 1)) {
    logit(phi[t]) <- alpha_phi0 + beta_time * (TIME[t] - 1)
    gamma[1, 1, t] <- phi[t]
    gamma[1, 2, t] <- 1 - phi[t]
    gamma[2, 1, t] <- 0
    gamma[2, 2, t] <- 1
  }
  alpha_phi0 ~ dnorm(0, sd = 1.5)
  beta_time ~ dnorm(0, sd = 1.5)

  for (i in 1:N) {
    z[i, first[i]] ~ dcat(delta[1:2])
    for (j in (first[i] + 1):T) {
      z[i, j] ~ dcat(gamma[z[i, j - 1], 1:2, j - 1])
      y[i, j] ~ dcat(omega[z[i, j], 1:2, i])
    }
  }
})
```

Setting the constants :

```{r}
my.constants <- list(N = N, T = T, first = first, SEX = SEX, K = K, TIME = TIME)
```

Initial values of the four Markov Chains :

```{r}
makeinits <- function() {
  list(
    p = runif(K, 0, 1),
    alpha_phi0 = rnorm(1, 0, 1),
    beta_time = rnorm(1, 0, 1),
    z = t(apply(y, 1, zinits))
  )
}

initial.values <- replicate(4, makeinits(), simplify = FALSE)
```

Parameters to monitor :

```{r}
params <- c("alpha_phi0","beta_time","p")
```

Running the MCMC :

```{r}
mcmc_p.sex_phi.timeCONT <- nimbleMCMC(
  code = hmm.p.sex_phi.timeCONT,
  constants = my.constants,
  data = my.data,
  inits = initial.values,
  monitors = params,
  niter = n_iter,
  nburnin = n_burnin,
  nchains = 4,
  summary = TRUE,
  setSeed = chain_seeds,
  WAIC = TRUE
)
```

```{r}
#| eval: true

mcmc_p.sex_phi.timeCONT$WAIC
```

### Summary WAIC

| Model | time          | WAIC |
|-------|---------------|------|
| 5     | random effect | 533  |
| 6     | categorical   | 529  |
| 7     | continuous    | 535  |

The best model for time-dependent $\phi$ was **model 6** (time as a categorical covariate), so we used this model as the basis for selecting the best model for $\phi$ that also included sex.

## Comparison of sex effect for p

### Model 8

|      | $p$         | $\phi$      |
|------|-------------|-------------|
| Time | constant    | categorical |
| Sex  | categorical | categorical |

Model code :

```{r}
hmm.p.sex_phi.timeCAT.sex <- nimbleCode({
  delta[1] <- 1
  delta[2] <- 0

  alpha_phi0 ~ dnorm(0, sd = 1.5)

  beta_phi_sex[1] <- 0
  for (k in 2:K) {
    beta_phi_sex[k] ~ dnorm(0, sd = 1.5)
  }

  beta_phi_time[1] <- 0
  for (t in 2:(T - 1)) {
    beta_phi_time[t] ~ dnorm(0, sd = 1.5)
  }

  for (k in 1:K) {
    for (t in 1:(T - 1)) {
      logit(phi[k, t]) <- alpha_phi0 + beta_phi_time[t] + beta_phi_sex[k]
    }
  }

  for (i in 1:N) {
    for (t in 1:(T - 1)) {
    gamma[1, 1, i, t] <- phi[SEX[i], t]
    gamma[1, 2, i, t] <- 1 - phi[SEX[i], t]
    gamma[2, 1, i, t] <- 0
    gamma[2, 2, i, t] <- 1
    }
  }

      
  for (k in 1:K) {
    p[k] ~ dunif(0, 1)
  }

  for (i in 1:N) {
    omega[1, 1, i] <- 1 - p[SEX[i]]
    omega[1, 2, i] <- p[SEX[i]]
    omega[2, 1, i] <- 1
    omega[2, 2, i] <- 0
  }

  for (i in 1:N) {
    z[i, first[i]] ~ dcat(delta[1:2])
    for (j in (first[i] + 1):T) {
      z[i, j] ~ dcat(gamma[z[i, j - 1], 1:2, i, j - 1])
      y[i, j] ~ dcat(omega[z[i, j], 1:2, i])
    }
  }
})
```

Setting the constants :

```{r}
my.constants <- list(N = N, T = T, first = first, SEX = SEX, K = K)
```

Initial values of the four Markov Chains :

```{r}
makeinits <- function() {
  list(
    p = runif(K, 0, 1),
    alpha_phi0 = rnorm(1, 0, sd = 1.5),
    beta_phi_sex = c(0, rnorm(K - 1, 0, 1.5)),
    beta_phi_time = c(0, rnorm(T - 2, 0, sd = 1.5)),
    z = t(apply(y, 1, zinits))
  )
}

initial.values <- replicate(4, makeinits(), simplify = FALSE)
```

Parameters to monitor :

```{r}
params <- c("p", "beta_phi_sex", "alpha_phi0", "beta_phi_time")
```

Running the MCMC :

```{r}
mcmc_p.sex_phi.timeCAT.sex <- nimbleMCMC(
  code = hmm.p.sex_phi.timeCAT.sex,
  constants = my.constants,
  data = my.data,
  inits = initial.values,
  monitors = params,
  niter = n_iter,
  nburnin = n_burnin,
  nchains = 4,
  summary = TRUE,
  setSeed = chain_seeds,
  WAIC = TRUE
)
```

```{r}
#| eval: true

mcmc_p.sex_phi.timeCAT.sex$WAIC
```

## Overall WAIC

| Model | $p$ \~ sex  | $p$ \~ time | $\phi$ \~ sex | $\phi$ \~ time |   WAIC    |
|-------|-------------|-------------|---------------|----------------|-----------|
|   1   |  constant   |  constant   |   constant    |    constant    |    541    |
|   2   |  constant   |     RE      |   constant    |    constant    |    553    |
|   3   |  constant   | categorical |   constant    |    constant    |    557    |
|   4   | categorical |  constant   |   constant    |    constant    |    537    |
|   5   |     cat     |  constant   |   constant    |       RE       |    533    |
|   6   |     cat     |  constant   |   constant    |  categorical   | **529\*** |
|   7   |     cat     |  constant   |   constant    |    constant    |    535    |
|   8   |     cat     |  constant   |  categorical  |  categorical   |    532    |

cat = categorical ; RE = random effect

**\***Best model

Therefore, we selected **model 6** for subsequent analyses.

## Output of best model

```{r}
#| eval: true
MCMCtrace(
  object = mcmc_p.sex_phi.timeCAT$samples,
  pdf = FALSE,
  ind = TRUE,
  params = c('p', 'phi')
)
```

```{r}
#| eval: true

MCMCsummary(mcmc_p.sex_phi.timeCAT$samples)
```

# 2. Effect of oxychlordane (OXY)

## Encode oxy

Encoding $log(OXY)$ as a continuous variable (OXY) :

```{r}
log_oxy <- log(raw_data$oxy)
```

Encoding $log(OXY)$ as a categorical variable (OXYD) :

```{r}
quantiles <- quantile(log_oxy, probs = seq(0, 1, by = 0.1))

oxyd <- log_oxy |>
  cut(
    breaks = quantiles,
    labels = seq(1, 10, 1),
    include.lowest = TRUE
  ) |>
  as.numeric()
```

Pool all first deciles together and the last n together :

```{r}

pool_n <- function(data, sex, n_female, n_male) {
  levels <- sort(unique(data))
  topD_f <- tail(levels, n_female)
  topD_m <- tail(levels, n_male)

  groups <- data

  groups[sex == 2 &  (data %in% topD_f)] <- max(levels) # n last deciles grouped together for females
  groups[sex == 2 & !(data %in% topD_f)] <- 1 # other deciles grouped together for females
  groups[sex == 1 &  (data %in% topD_m)] <- max(levels) # n last deciles grouped together for males
  groups[sex == 1 & !(data %in% topD_m)] <- 1 # other deciles grouped together for males

  match(groups, sort(unique(groups))) # create 2 groups : low and high oxy levels
}

```

```{r}
data.frame(x = oxyd, SEX = raw_data$sex, y = pool_n(oxyd, raw_data$sex, n_female = 2, n_male = 1))
```

## Model 1 : log(OXY) as a continuous variable

An increasing pollutant dose is assumed to lead to a progressive decrease in survival.

Scale $log(OXY)$

```{r}
log_oxy_sc <- as.vector(scale(log_oxy))
```

```{r}
hmm.p.sex_phi.timeCAT.oxyCONT <- nimbleCode({
  delta[1] <- 1          
  delta[2] <- 0 
  
  for(k in 1:K){
    p[k] ~ dunif(0,1)
  }
  
  for(i in 1:N){
    omega[1,1,i] <- 1 - p[SEX[i]]
    omega[1,2,i] <- p[SEX[i]]
    omega[2,1,i] <- 1
    omega[2,2,i] <- 0
  }
  
  beta_time[1] <- 0
  for(t in 2:(T-1)){
    beta_time[t] ~ dnorm(0, sd = 1.5)
  }
  
  for (t in 1:(T-1)) {
    for (i in 1:N) {
      logit(phi[i,t]) <- alpha_phi0 + beta_oxy * OXY[i] + beta_time[t]
      gamma[1,1,i,t] <- phi[i,t]       
      gamma[1,2,i,t] <- 1 - phi[i,t]   
      gamma[2,1,i,t] <- 0              
      gamma[2,2,i,t] <- 1              
    }
  }
  
  alpha_phi0 ~ dnorm(0, sd = 1.5)
  beta_oxy   ~ dnorm(0, sd = 1.5) 
  
  for(i in 1:N){
    z[i, first[i]] ~ dcat(delta[1:2])
    for(j in (first[i]+1):T){
      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2,i,j-1])
      y[i,j] ~ dcat(omega[z[i,j], 1:2,i])
    }
  }
})
```

```{r}
my.constants <- list(
  N = N,
  T = T,
  SEX = SEX,
  K = K,
  first = first,
  OXY = log_oxy_sc
)
```

```{r}
makeinits <- function() {
  list(
    p = runif(K,0,1),
    alpha_phi0 = rnorm(1,0,1),
    beta_oxy = rnorm(1,0,1),
    beta_time = c(0, rnorm(T-2,0,1.5)),
    z = t(apply(y, 1, zinits))
  )
}

initial.values <- replicate(4, makeinits(), simplify = FALSE)
```

```{r}
params = c("p", "alpha_phi0", "beta_oxy", "beta_time")
```

```{r}
mcmc_p.sex_phi.timeCAT.oxyCONT <- nimbleMCMC(
  code = hmm.p.sex_phi.timeCAT.oxyCONT,
  constants = my.constants,
  data = my.data,
  inits = initial.values,
  monitors = params,
  niter = n_iter,
  nburnin = n_burnin,
  nchains = n_chains,
  summary = TRUE,
  setSeed = chain_seeds,
  WAIC = TRUE
)
```

```{r}
#| eval: true

mcmc_p.sex_phi.timeCAT.oxyCONT$WAIC
```

## Model 2 : log(OXY) as a categorical variable

A threshold effect may exist, below which the pollutant has no impact on survival, as well as a saturation effect at high doses, beyond which additional accumulation no longer affects survival. Such patterns could be highlighted by using classes.

```{r}
G <- length(unique(oxyd))

hmm.p.sex_phi.timeCAT.oxyCAT <- nimbleCode({
  delta[1] <- 1          
  delta[2] <- 0 
  
  for(k in 1:K){
    p[k] ~ dunif(0,1)
  }
  
  for(i in 1:N){
    omega[1,1,i] <- 1 - p[SEX[i]]
    omega[1,2,i] <- p[SEX[i]]
    omega[2,1,i] <- 1
    omega[2,2,i] <- 0
  }
  
  beta_time[1] <- 0
  for(t in 2:(T-1)){
    beta_time[t] ~ dnorm(0, sd = 1.5)
  }
  
  beta_oxy[1] <- 0
  for(g in 2:G){
    beta_oxy[g] ~ dnorm(0, sd = 1.5)
  }
  
  for(g in 1:G){
    for (t in 1:(T-1)){
      logit(phi[g,t]) <- alpha_phi0 + beta_oxy[g] + beta_time[t]
    }
  }
  
  for(i in 1:N){
    for(t in 1:(T-1)){
      gamma[1,1,i,t] <- phi[oxyd[i],t]      
      gamma[1,2,i,t] <- 1 - phi[oxyd[i],t]  
      gamma[2,1,i,t] <- 0           
      gamma[2,2,i,t] <- 1           
    }
  }

  
  alpha_phi0 ~ dnorm(0, sd = 1.5)
  
  for(i in 1:N){
    z[i, first[i]] ~ dcat(delta[1:2])
    for(j in (first[i]+1):T){
      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2,i,j-1])
      y[i,j] ~ dcat(omega[z[i,j], 1:2,i])
    }
  }
})
```

```{r}
my.constants <- list(
  N = N,
  T = T,
  first = first,
  SEX = SEX,
  K = K,
  oxyd = oxyd,
  G = G
)
```

```{r}
makeinits <- function() {
  list(
    p = runif(K,0,1),
    alpha_phi0 = rnorm(1,0,1),
    beta_oxy = c(0, rnorm(G-1,0,1)),
    beta_time = c(0, rnorm(T-2,0,1.5)),
    z = t(apply(y, 1, zinits))
  )
}

initial.values <- replicate(4, makeinits(), simplify = FALSE)
```

```{r}
params <- c("p", "phi","alpha_phi0", "beta_oxy", "beta_time")
```

```{r}
mcmc_p.sex_phi.timeCAT.oxyCAT <- nimbleMCMC(
  code = hmm.p.sex_phi.timeCAT.oxyCAT,
  constants = my.constants,
  data = my.data,
  inits = initial.values,
  monitors = params,
  niter = n_iter,
  nburnin = n_burnin,
  nchains = n_chains,
  setSeed = chain_seeds,
  summary = TRUE,
  WAIC = TRUE
)
```

```{r}
#| eval: true

mcmc_p.sex_phi.timeCAT.oxyCAT$WAIC
```

## Model 3 : log(OXY) as a pooled categorical variable (9 first deciles)

```{r}
oxyd_D9 <- pool_n(oxyd, raw_data$sex, 1, 1)
G <- length(unique(oxyd_D9))
```

```{r}
my.constants <- list(
  N = N,
  T = T,
  SEX = SEX,
  K = K,
  G = G,
  first = first,
  oxyd = oxyd_D9
)
```

```{r}
initial.values <- replicate(4, makeinits(), simplify = FALSE)
```

```{r}
mcmc_p.sex_phi.timeCAT.oxyCATD9 <- nimbleMCMC(
  code = hmm.p.sex_phi.timeCAT.oxyCAT,
  constants = my.constants,
  data = my.data,
  inits = initial.values,
  monitors = params,
  niter = n_iter,
  nburnin = n_burnin,
  nchains = n_chains,
  setSeed = chain_seeds,
  summary = TRUE,
  WAIC = TRUE
)
```

```{r}
#| eval: true

mcmc_p.sex_phi.timeCAT.oxyCATD9$WAIC
```

## Model 4 : log(OXY) as a pooled categorical variable (8 first deciles)

```{r}
oxyd_D8 <- pool_n(oxyd, raw_data$sex, 2, 2)
G <- length(unique(oxyd_D8))
```

```{r}
constants <- list(
  N = N,
  T = T,
  SEX = SEX,
  K = K,
  G = G,
  first = first,
  oxyd = oxyd_D8
)
```

```{r}
initial.values <- replicate(4, makeinits(), simplify = FALSE)
```

```{r}
mcmc_p.sex_phi.timeCAT.oxyCATD8 <- nimbleMCMC(
  code = hmm.p.sex_phi.timeCAT.oxyCAT,
  constants = constants,
  data = my.data,
  inits = initial.values,
  monitors = params,
  niter = n_iter,
  nburnin = n_burnin,
  nchains = n_chains,
  setSeed = chain_seeds,
  summary = TRUE,
  WAIC = TRUE
)
```

```{r}
#| eval: true

mcmc_p.sex_phi.timeCAT.oxyCATD8$WAIC
```

## Model 5 : log(OXY) as a categorical variable in interaction with sex

We decided to test this model to determine whether the optimal oxy threshold differs between sexes.

```{r}
G <- length(unique(oxyd))

hmm.p.sex_phi.timeCAT.oxyCAT_intsex <- nimbleCode({
  delta[1] <- 1          
  delta[2] <- 0 
  
  for(k in 1:K){
    p[k] ~ dunif(0,1)
  }
  
  for(i in 1:N){
    omega[1,1,i] <- 1 - p[SEX[i]]
    omega[1,2,i] <- p[SEX[i]]
    omega[2,1,i] <- 1
    omega[2,2,i] <- 0
  }
  
  beta_time[1] <- 0
  for(t in 2:(T-1)){
    beta_time[t] ~ dnorm(0, sd = 1.5)
  }
  
  beta_oxy[1] <- 0
  for(g in 2:G){
    beta_oxy[g] ~ dnorm(0, sd = 1.5)
  }
  
  beta_sex[1] <- 0
  for(k in 2:K){
    beta_sex[k] ~ dnorm(0, sd = 1.5)
  }
  
  beta_int[1,1] <- 0
  for (g in 2:G) { beta_int[g,1] <- 0 }
  for (k in 2:K) { beta_int[1,k] <- 0 }
  for (g in 2:G) {
    for (k in 2:K) {
      beta_int[g,k] ~ dnorm(0, sd = 1.5)
    }
  }
  
  for (t in 1:(T-1)) {
    for (g in 1:G) {
      for (k in 1:K) {
        logit(phi[g,k,t]) <- alpha_phi0 + beta_oxy[g] +
          beta_time[t] + beta_sex[k] + beta_int[g,k]
      }
    }
  }
  
  for(i in 1:N){
    for(t in 1:(T-1)){
      gamma[1,1,i,t] <- phi[oxyd[i], SEX[i], t]      
      gamma[1,2,i,t] <- 1 - phi[oxyd[i], SEX[i], t]  
      gamma[2,1,i,t] <- 0           
      gamma[2,2,i,t] <- 1           
    }
  }
  
  
  alpha_phi0 ~ dnorm(0, sd = 1.5)
  
  for(i in 1:N){
    z[i, first[i]] ~ dcat(delta[1:2])
    for(j in (first[i]+1):T){
      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2,i,j-1])
      y[i,j] ~ dcat(omega[z[i,j], 1:2,i])
    }
  }
})
```

```{r}
my.constants <- list(
  N = N,
  T = T,
  first = first,
  SEX = SEX,
  K = K,
  oxyd = oxyd,
  G = G
)
```

```{r}
makeinits <- function() {
  beta_int <- matrix(0, nrow = G, ncol = K)
  if (G > 1 && K > 1) {
    beta_int[2:G, 2:K] <- matrix(
      rnorm((G - 1) * (K - 1), 0, 1.0),
      nrow = G - 1,
      ncol = K - 1
    )
  }
  list(
    p = runif(K, 0, 1),
    alpha_phi0 = rnorm(1, 0, 1),
    beta_oxy = c(0, rnorm(G - 1, 0, 1)),
    beta_time = c(0, rnorm(T - 2, 0, 1.5)),
    beta_int = beta_int,
    beta_sex = c(0, rnorm(K - 1, 0, 1.5)),
    z = t(apply(y, 1, zinits))
  )
}

initial.values <- replicate(4, makeinits(), simplify = FALSE)
```

```{r}
params <- c(
  "p",
  "phi",
  "alpha_phi0",
  "beta_oxy",
  "beta_time",
  "beta_int",
  "beta_sex"
)
```

```{r}
mcmc_p.sex_phi.timeCAT.oxyCAT_intsex <- nimbleMCMC(
  code = hmm.p.sex_phi.timeCAT.oxyCAT_intsex,
  constants = my.constants,
  data = my.data,
  inits = initial.values,
  monitors = params,
  niter = n_iter,
  nburnin = n_burnin,
  nchains = n_chains,
  setSeed = chain_seeds,
  summary = TRUE,
  WAIC = TRUE
)
```

```{r}
#| eval: true

mcmc_p.sex_phi.timeCAT.oxyCAT_intsex$WAIC
```

## Model 6 : log(OXY) as a categorical variable in interaction with sex : 9 first deciles grouped for males and 8 first deciles grouped for females.

This model allows us to account for different effects of the "high" levels of oxy on survival according to sex.

```{r}
oxyd_D8F_D9M <- pool_n(oxyd, raw_data$sex, n_female = 2, n_male = 1)
G <- length(unique(oxyd_D8F_D9M))
```

```{r}
my.constants <- list(
  N = N,
  T = T,
  first = first,
  SEX = SEX,
  K = K,
  oxyd = oxyd_D8F_D9M,
  G = G
)
```

```{r}
initial.values <- replicate(4, makeinits(), simplify = FALSE)
```

```{r}
params <- c(
  "p",
  "phi",
  "alpha_phi0",
  "beta_oxy",
  "beta_time",
  "beta_int",
  "beta_sex"
)
```

```{r}
mcmc_p.sex_phi.timeCAT.oxyCAT_D8FD9M_intsex <- nimbleMCMC(
  code = hmm.p.sex_phi.timeCAT.oxyCAT_intsex,
  constants = my.constants,
  data = my.data,
  inits = initial.values,
  monitors = params,
  niter = n_iter,
  nburnin = n_burnin,
  nchains = n_chains,
  setSeed = chain_seeds,
  summary = TRUE,
  WAIC = TRUE
)
```

```{r}
#| eval: true

mcmc_p.sex_phi.timeCAT.oxyCAT_D8FD9M_intsex$WAIC
```

## Model 7 : log(OXY) as a categorical variable : 9 first deciles grouped for males and 8 first deciles grouped for females.

In this model, there is no interaction with sex. This implies that, although high oxy levels differ between females and males, their effect on survival is the same for both sexes.

```{r}
oxyd_D8F_D9M <- pool_n(oxyd, raw_data$sex, n_female = 2, n_male = 1)
G <- length(unique(oxyd_D8F_D9M))
```

```{r}
hmm.p.sex_phi.timeCAT.oxyCAT_D8FD9M_additive <- nimbleCode({
  delta[1] <- 1          
  delta[2] <- 0 
  
  for(k in 1:K){
    p[k] ~ dunif(0,1)
  }
  
  for(i in 1:N){
    omega[1,1,i] <- 1 - p[SEX[i]]
    omega[1,2,i] <- p[SEX[i]]
    omega[2,1,i] <- 1
    omega[2,2,i] <- 0
  }
  
  beta_time[1] <- 0
  for(t in 2:(T-1)){
    beta_time[t] ~ dnorm(0, sd = 1.5)
  }
  
  beta_oxy[1] <- 0
  for(g in 2:G){
    beta_oxy[g] ~ dnorm(0, sd = 1.5)
  }
  
  for (t in 1:(T-1)) {
    for (g in 1:G) {
        logit(phi[g,t]) <- alpha_phi0 + beta_oxy[g] +
          beta_time[t]
      }
    }
  
  for(i in 1:N){
    for(t in 1:(T-1)){
      gamma[1,1,i,t] <- phi[oxyd[i], t]      
      gamma[1,2,i,t] <- 1 - phi[oxyd[i], t]  
      gamma[2,1,i,t] <- 0           
      gamma[2,2,i,t] <- 1           
    }
  }
  
  
  alpha_phi0 ~ dnorm(0, sd = 1.5)
  
  for(i in 1:N){
    z[i, first[i]] ~ dcat(delta[1:2])
    for(j in (first[i]+1):T){
      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2,i,j-1])
      y[i,j] ~ dcat(omega[z[i,j], 1:2,i])
    }
  }
})
```

```{r}
my.constants <- list(
  N = N,
  T = T,
  first = first,
  SEX = SEX,
  K = K,
  oxyd = oxyd_D8F_D9M,
  G = G
)
```

```{r}
makeinits <- function() {
  list(
    p = runif(K, 0, 1),
    alpha_phi0 = rnorm(1, 0, 1),
    beta_oxy = c(0, rnorm(G - 1, 0, 1)),
    beta_time = c(0, rnorm(T - 2, 0, 1.5)),
    z = t(apply(y, 1, zinits))
  )
}

initial.values <- replicate(4, makeinits(), simplify = FALSE)
```

```{r}
params <- c("p", "phi","alpha_phi0", "beta_oxy", "beta_time")
```

```{r}
mcmc_p.sex_phi.timeCAT.oxyCAT_D8FD9M_additive <- nimbleMCMC(
  code = hmm.p.sex_phi.timeCAT.oxyCAT_D8FD9M_additive,
  constants = my.constants,
  data = my.data,
  inits = initial.values,
  monitors = params,
  niter = n_iter,
  nburnin = n_burnin,
  nchains = n_chains,
  setSeed = chain_seeds,
  summary = TRUE,
  WAIC = TRUE
)
```

```{r}
#| eval: true

mcmc_p.sex_phi.timeCAT.oxyCAT_D8FD9M_additive$WAIC
```

## Model 8 : log(OXY) as a categorical variable : 8 first deciles grouped for males and 9 first deciles grouped for females.

We still wanted to try the best model of the article.

```{r}
oxyd_D9F_D8M <- pool_n(oxyd, raw_data$sex, n_female = 2, n_male = 1)
G <- length(unique(oxyd_D9F_D8M))
```

```{r}
hmm.p.sex_phi.timeCAT.oxyCAT_D9FD8M_additive <- nimbleCode({
  delta[1] <- 1
  delta[2] <- 0

  for (k in 1:K) {
    p[k] ~ dunif(0, 1)
  }

  for (i in 1:N) {
    omega[1, 1, i] <- 1 - p[SEX[i]]
    omega[1, 2, i] <- p[SEX[i]]
    omega[2, 1, i] <- 1
    omega[2, 2, i] <- 0
  }

  beta_time[1] <- 0
  for (t in 2:(T - 1)) {
    beta_time[t] ~ dnorm(0, sd = 1.5)
  }

  beta_oxy[1] <- 0
  for (g in 2:G) {
    beta_oxy[g] ~ dnorm(0, sd = 1.5)
  }

  for (t in 1:(T - 1)) {
    for (g in 1:G) {
      logit(phi[g, t]) <- alpha_phi0 + beta_oxy[g] + beta_time[t]
    }
  }

  for (i in 1:N) {
    for (t in 1:(T - 1)) {
      gamma[1, 1, i, t] <- phi[oxyd[i], t]
      gamma[1, 2, i, t] <- 1 - phi[oxyd[i], t]
      gamma[2, 1, i, t] <- 0
      gamma[2, 2, i, t] <- 1
    }
  }

  alpha_phi0 ~ dnorm(0, sd = 1.5)

  for (i in 1:N) {
    z[i, first[i]] ~ dcat(delta[1:2])
    for (j in (first[i] + 1):T) {
      z[i, j] ~ dcat(gamma[z[i, j - 1], 1:2, i, j - 1])
      y[i, j] ~ dcat(omega[z[i, j], 1:2, i])
    }
  }
})
```

```{r}
my.constants <- list(
  N = N,
  T = T,
  first = first,
  SEX = SEX,
  K = K,
  oxyd = oxyd_D9F_D8M,
  G = G
)
```

```{r}
makeinits <- function() {
  list(
    p = runif(K, 0, 1),
    alpha_phi0 = rnorm(1, 0, 1),
    beta_oxy = c(0, rnorm(G - 1, 0, 1)),
    beta_time = c(0, rnorm(T - 2, 0, 1.5)),
    z = t(apply(y, 1, zinits))
  )
}

initial.values <- replicate(4, makeinits(), simplify = FALSE)
```

```{r}
params <- c("p", "phi","alpha_phi0", "beta_oxy", "beta_time")
```

```{r}
mcmc_p.sex_phi.timeCAT.oxyCAT_D9FD8M_additive <- nimbleMCMC(
  code = hmm.p.sex_phi.timeCAT.oxyCAT_D9FD8M_additive,
  constants = my.constants,
  data = my.data,
  inits = initial.values,
  monitors = params,
  niter = n_iter,
  nburnin = n_burnin,
  nchains = n_chains,
  setSeed = chain_seeds,
  summary = TRUE,
  WAIC = TRUE
)
```

```{r}
#| eval: true

mcmc_p.sex_phi.timeCAT.oxyCAT_D9FD8M_additive$WAIC
```

## Summary WAIC

| Model | oxy                      | WAIC    |
|-------|--------------------------|---------|
| 1     | continuous               | **531** |
| 2     | categorical              | **532** |
| 3     | categorical D9           | **530** |
| 4     | categorical D8           | **531** |
| 5     | categorical x sex        | 537     |
| 6     | categorical D8FD9M x sex | **531** |
| 7     | categorical D8FD9M       | **530** |
| 8     | categorical D9FD8M       | **530** |

\*Best models : 2 models were considered equivalent if their $\Delta$WAIC was ≤ 2.

Since all models (except model 5) produced very similar WAIC values, we choose to represent only model 1 as it is the most parcimonious one.

## Output of the best model

```{r}
#| eval: true
MCMCtrace(
  object = mcmc_p.sex_phi.timeCAT.oxyCONT$samples,
  pdf = FALSE,
  ind = TRUE,
  params = c("p", "alpha_phi0", "beta_oxy", "beta_time")
)
```

```{r}
#| eval: true

MCMCsummary(mcmc_p.sex_phi.timeCAT.oxyCONT$samples)
```